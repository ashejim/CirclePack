/*
 * FunctionParser.java
 *
 * Created on August 14, 2006, 4:31 PM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */

package com.jimrolf.functionparser;

import com.jimrolf.complex.Complex;
import org.lsmp.djep.djep.DJep;
import org.nfunk.jep.ParseException;
import org.nfunk.jep.function.Factorial;
import org.nfunk.jep.function.Sign;

/**
 * 
 * This is a wrapper class designed to be independent of parser and allows programmer 
 * to substitute parser class of choice.  Current parser is DJEP2.4 found at
 * <CODE><p></CODE>
 * <CODE><p align="center"><a href="http://www.singularsys.com/jep">www.singularsys.com/jep/</a></CODE> 
 * <CODE><p></CODE>
 * To use the basic functionality of this class:
 * <CODE>
 *     <ol>
 *         <li>Instantiate the class using a constructor. This initializes the usual functions and constants. 
 *         The default variable is 'x'.  All the usual real constants and variables are available to the user.  Implicit multiplication is allowed 
 * (i.e. '2x' is the same as '2*x'). Parser can find derivatives of parsed expression.
 * <li>Parse a string representing the presumed function with the parseExpression(String funcInput) method.
 * If Complex constants and functions are desired, use the setComplex(boolean complex) method to turn these on.
 * <li>Evaluate function using one of the evalFunc() methods.  For example, to return a double, 
 * the evalFunc(double x) method should be used.
 * <li>Compute derivative using the computeDeriv() method.  User can determine which derivative has been 
 * computed via the getWhichDeriv() method.
 * <li>Evaluate the derivative function generated by step #4 via one of the evalDeriv() methods.
 * <li>Check for errors using the funcHasError() and/or the derivHasError() methods.
 * <li>Get specific error information via the getFuncErrorInfo() and/or getDerivError() methods.
 * </ol></CODE>
 * @author Jim Rolf
 * @email jim@jimrolf.com
 */
public class FunctionParser {

    private String constantName=null; //defines a constant in the parser.
    private double constantValue=0.0;

     public void removeConstant(String constantName){
        funcParser.removeVariable(constantName);
        this.constantName=null;
    }

    public void setConstant(String constantName,double constantValue){
       /*
        if (this.constantName!=null){
            funcParser.removeVariable(this.constantName);
        }*/
        this.constantName=constantName;
        this.constantValue=constantValue;

        funcParser.addConstant(constantName,constantValue);
        //funcParser.addVariable(constantName,constantValue);
    }
    
    /**
     * Set this to true in order to parse 2x as 2*x. If set to false, 2x is parsed as a variable only.
     */
    protected boolean implicitMultiplication=true;

    /**
     *Used to parse string funcInput and to evaluate function.
     */
    protected DJep funcParser=null;

    /**
     *Used to parse string derivINput and to evaluate derivative.
     */
    protected DJep derivParser=null;
    
    /**
     *funcInput is the string representing the function.
     */
    protected String funcInput=null;

    /**
     *variable represents the variable against which the funcInput is parsed.
     */
    protected String variable=null;
    
    /**
     *array containing variables for use in multi-dimensional functions
     */
    protected String[] variables=null;

    /**
     *default is false => single variable
     */
    protected boolean multiDimensional=false; 

    /**
     *useAllVariables==true is for special case when needing to use both variable and variables to hold info.
     */
    protected boolean useAllVariables=false;  

    /**
     *Contains value of variable.
     */
    protected double variableValue=0.0;

    /**
     *derivInput is String representing derivative.  Call one of the computeDeriv methods to generate this.
     */
    protected String derivInput=null;

    /**
     *funcHasError value is assigned when parsing funcInput
     */
    protected boolean funcHasError=false;

    /**
     *derivHasError value is assigned when parsring derivInput
     */
    protected boolean derivHasError=false;

    /**
     *Error information from parsing funcInput is here.
     */
    protected String funcErrorInfo=null;

    /**
     *Error information from parsing derivInput is here.
     */
    protected String derivErrorInfo=null;

    /**
     *String representing partial derivatives are here.
     */
    protected String[] partialDerivInput=null;
    
    /**
     *whichDeriv keeps track of homw many derivatives have been computed.
     */
    protected int whichDeriv=0;

    public String[] getPartialDerivInput(){
        return this.partialDerivInput;
    }

    public String getPartialDerivInput(int index){
        return this.partialDerivInput[index];
    }


    /**
     *Error information from computing partial derivatives.
     */
    protected String[] partialDerivErrorInfo = null;

    /**
     * Get the value of partialDerivErrorInfo
     *
     * @return the value of partialDerivErrorInfo
     */
    public String[] getPartialDerivErrorInfo() {
        return partialDerivErrorInfo;
    }

    /**
     * Set the value of partialDerivErrorInfo
     *
     * @param partialDerivErrorInfo new value of partialDerivErrorInfo
     */
    public void setPartialDerivErrorInfo(String[] partialDerivErrorInfo) {
        this.partialDerivErrorInfo = partialDerivErrorInfo;
    }

    /**
     * Get the value of partialDerivErrorInfo at specified index
     *
     * @param index
     * @return the value of partialDerivErrorInfo at specified index
     */
    public String getPartialDerivErrorInfo(int index) {
        return this.partialDerivErrorInfo[index];
    }

    /**
     * Set the value of partialDerivErrorInfo at specified index.
     *
     * @param index
     * @param newPartialDerivErrorInfo new value of partialDerivErrorInfo at specified index
     */
    public void setPartialDerivErrorInfo(int index, String newPartialDerivErrorInfo) {
        this.partialDerivErrorInfo[index] = newPartialDerivErrorInfo;
    }


    /**
     *Error information produced by computing partial derivatives is stored here.
     */
    protected boolean[] partialDerivHasError = null;

    /**
     * Get the value of partialDerivHasError
     *
     * @return the value of partialDerivHasError
     */
    public boolean[] partialDerivHasError() {
        return partialDerivHasError;
    }

    /**
     * Set the value of partialDerivHasError
     *
     * @param partialDerivHasError new value of partialDerivHasError
     */
    public void setPartialDerivHasError(boolean[] partialDerivHasError) {
        this.partialDerivHasError = partialDerivHasError;
    }

    /**
     * Get the value of partialDerivHasError at specified index
     *
     * @param index
     * @return the value of partialDerivHasError at specified index
     */
    public boolean partialDerivHasError(int index) {
        return this.partialDerivHasError[index];
    }

    /**
     * Set the value of partialDerivHasError at specified index.
     *
     * @param index
     * @param newPartialDerivHasError new value of partialDerivHasError at specified index
     */
    public void setPartialDerivHasError(int index, boolean newPartialDerivHasError) {
        this.partialDerivHasError[index] = newPartialDerivHasError;
    }


    /**
     *
     */
    protected DJep[] partialDerivParser = null;

    /**
     * Get the value of partialDerivParser
     *
     * @return the value of partialDerivParser
     */
    public DJep[] getPartialDerivParser() {
        return partialDerivParser;
    }

    /**
     * Set the value of partialDerivParser
     *
     * @param partialDerivParser new value of partialDerivParser
     */
    public void setPartialDerivParser(DJep[] partialDerivParser) {
        this.partialDerivParser = partialDerivParser;
    }

    /**
     * Get the value of partialDerivParser at specified index
     *
     * @param index
     * @return the value of partialDerivParser at specified index
     */
    public DJep getPartialDerivParser(int index) {
        return this.partialDerivParser[index];
    }

    /**
     * Set the value of partialDerivParser at specified index.
     *
     * @param index
     * @param newPartialDerivParser new value of partialDerivParser at specified index
     */
    public void setPartialDerivParser(int index, DJep newPartialDerivParser) {
        this.partialDerivParser[index] = newPartialDerivParser;
    }


    /**
     *Contains information about how many partial derivatives have been computed.
     */
    protected int[] whichPartialDeriv = null;

    /**
     * Get the value of whichPartialDeriv
     *
     * @return the value of whichPartialDeriv
     */
    public int[] getWhichPartialDeriv() {
        return whichPartialDeriv;
    }

    /**
     * Set the value of whichPartialDeriv
     *
     * @param whichPartialDeriv new value of whichPartialDeriv
     */
    public void setWhichPartialDeriv(int[] whichPartialDeriv) {
        this.whichPartialDeriv = whichPartialDeriv;
    }

    /**
     * Get the value of whichPartialDeriv at specified index
     *
     * @param index
     * @return the value of whichPartialDeriv at specified index
     */
    public int getWhichPartialDeriv(int index) {
        return this.whichPartialDeriv[index];
    }

    /**
     * Set the value of whichPartialDeriv at specified index.
     *
     * @param index
     * @param newWhichPartialDeriv new value of whichPartialDeriv at specified index
     */
    public void setWhichPartialDeriv(int index, int newWhichPartialDeriv) {
        this.whichPartialDeriv[index] = newWhichPartialDeriv;
    }
    
    protected int oldDimension=0;


    /**
     *Represents the dimension of the function.
     */
    protected int dimension=0;

    /**
     *
     * @param dimension
     */
    public void setDimension(int dimension){
        oldDimension=this.dimension;
        
        this.dimension=dimension;
        if (dimension>1){
            multiDimensional=true;
        }else{
            multiDimensional=false;
        }
        if(dimension>1){
            setUpMultiDimensionalStuff();
        }
    }

    /**
     *
     * @return
     */
    public int getDimension(){
        return this.dimension;
    }
    
    /**
     *Creates a new instance of FunctionParser.  Default variable is 'x'.
     */
    
    public FunctionParser(){
        funcParser=new DJep();
        initializeParser(funcParser);

        derivParser=new DJep();
        initializeParser(derivParser);
 
        variable="x";  //this is default  
    }
    
    /**
     * Creates a new instance of Function parser and parses funcInput with respect to variable
     * @param funcInput String representing function
     * @param variable String representing variable that should be used when parsing funcInput string
     */
    public FunctionParser(String funcInput, String variable){
        this.funcInput=funcInput;
        this.variable=variable;

        funcParser=new DJep();
        initializeParser(funcParser);
        derivParser=new DJep();
        initializeParser(derivParser);
        
        parseExpression(funcInput);
    }
    
    /**
     * Creates a new instance of FunctionParser and parses funcInput with respect to all variables in array variables.  this is used for a multi-dimensional function.
     * @param funcInput String representing function
     * @param variables String representing variable that should be used when parsing funcInput string
     */
   /* public FunctionParser(String funcInput, String[] variables){
        this.funcInput=funcInput;
        this.variables=variables;
        multiDimensional=true;

        funcParser=new DJep();
        initializeParser(funcParser);
        derivParser=new DJep();
        initializeParser(derivParser);
        
       
        parseExpression(funcInput);
    }*/

    protected void setUpMultiDimensionalStuff(){
        //multiDimensional=true;
        whichPartialDeriv=new int[dimension];
        partialDerivInput=new String[dimension];
        partialDerivParser=new DJep[dimension];
        partialDerivHasError=new boolean[dimension];
        partialDerivErrorInfo= new String[dimension];
        for (int i=0; i<=dimension-1; i++){
            partialDerivParser[i]=new DJep();
            initializeParser(partialDerivParser[i]);

            partialDerivHasError[i]=false;
            partialDerivErrorInfo[i]=null;
        }
    }

    /*
     * Pass in a parser, create, add standard functions and constants, diff rules,
     * set implicit multipplication, allow undeclared, and add non-standard functions
     */
    protected void initializeParser(DJep parser){
        //parser = new DJep();
        parser.addStandardFunctions();
        parser.addStandardConstants();
        parser.setAllowUndeclared(true);
        parser.setAllowAssignment(true);
        parser.setImplicitMul(true);
        parser.addStandardDiffRules();
        parser.addFunction("fact", new Factorial());
        parser.addFunction("sgn", new Sign());
    }
    
    /**
     *
     */
    public void simplifyFunc(){
        try{
            funcInput=funcParser.toString(funcParser.simplify(funcParser.parse(funcInput)));
        } catch(ParseException e){
            funcHasError=true;
        }
        
        funcParser.addVariable(variable,0.0);
        funcParser.parseExpression(funcInput);
    }
    
    /**
     * Use this to start parser over (i.e. when computing multiple derivatives) or when funcInput is known
     */
    public void parseExpression(){
        funcHasError = false; //need to do this in case we parse a different function
        funcErrorInfo = null;

        if (multiDimensional || useAllVariables) {
            if (useAllVariables) {
                this.derivInput = funcInput; //need this in order to take derivative
                funcParser.addVariable(variable, 0.0);
                derivParser.addVariable(variable, 0.0);//use this parser for derivative in this variable

                if (multiDimensional) {
                    for (int i = 0; i <= dimension - 1; i++) {
                        partialDerivParser[i].addVariable(variable, 0.0);
                    }
                }
            }

            if (multiDimensional) {
                for (int i = 0; i <= dimension - 1; i++) {
                    partialDerivInput[i] = funcInput;

                    funcParser.addVariable(variables[i], 0.0);
                    derivParser.addVariable(variables[i], 0.0);

                    for (int j = 0; j <= dimension - 1; j++) {
                        partialDerivParser[i].addVariable(variables[j], 0.0);
                    }
                }
            }

            funcParser.parseExpression(funcInput);
            if (funcParser.getErrorInfo() != null) {
                funcHasError = true;
                funcErrorInfo = funcParser.getErrorInfo();
            }

            if (useAllVariables) {
                derivParser.parseExpression(derivInput);
                if (derivParser.getErrorInfo() != null) {
                    derivHasError = true;
                    derivErrorInfo = derivParser.getErrorInfo();
                }
            }

            if (multiDimensional) {
                for (int i = 0; i <= dimension - 1; i++) {
                    partialDerivParser[i].parseExpression(partialDerivInput[i]);
                    if (partialDerivParser[i].getErrorInfo() != null) {
                        partialDerivHasError[i] = true;
                        partialDerivErrorInfo[i] = partialDerivParser[i].getErrorInfo();
                    } else {
                        partialDerivHasError[i] = false;
                    }
                }
            }


        } else {//single variable case
            this.derivInput = funcInput; //need this in order to take derivative

            derivHasError = false;
            derivErrorInfo = null;

            funcParser.addVariable(variable, 0.0);
            derivParser.addVariable(variable, 0.0); //getting derivParser ready. able to eval 0th deriv

            funcParser.parseExpression(funcInput);
            if (funcParser.getErrorInfo() != null) {
                funcHasError = true;
                funcErrorInfo = funcParser.getErrorInfo();
            }

            derivParser.parseExpression(derivInput);
            if (derivParser.getErrorInfo() != null) {
                derivHasError = true;
                derivErrorInfo = derivParser.getErrorInfo();
            }
        }
    }
    
    
    /**
     * Primary method to convert String to mathematical function.
     * @param funcInput String representing function.
     */
    public void parseExpression(String funcInput){
        this.funcInput=funcInput;
        parseExpression();
    }
    
    /**
     * Evaluates function
     * @param x double in domain of function.
     * @return Returns a double
     */
    public double evalFunc(double x){
        funcParser.addVariable(variable,x);
        return funcParser.getValue();
    }
    
    /**
     * Evaluates function
     * @param x double in domain of function.
     * @param y double in domain of function.
     * @return Returns a double
     */
    public double evalFunc(double x, double y){
        funcParser.addVariable(variables[0],x);
        funcParser.addVariable(variables[1],y);
        return funcParser.getValue();
    }

    /**
     * Evaluates function
     * @param x double in domain of function.
     * @param y double in domain of function.
     * @param z double in domain of function.
     * @return Returns a double
     */
    public double evalFunc(double x, double y, double z){
        funcParser.addVariable(variables[0],x);
        funcParser.addVariable(variables[1],y);
        funcParser.addVariable(variables[2],z);
        return funcParser.getValue();
    }
    
    
    /**
     * Evaluates Complex function.
     * @param z Object of type Complex in the domain of function.
     * @return Returns object of type Complex
     */
    public Complex evalFunc(Complex z){
        funcParser.addVariable(variable,z);
        return funcParser.getComplexValue();
    }


    public Complex evalFunc(Complex z, Complex w){
        funcParser.addVariable(variables[0], z);
        funcParser.addVariable(variables[1],w);
        return funcParser.getComplexValue();
    }


    
    /**
     * Evaluates function whose domain is an integer. Useful if user knows function requires an int argument 
     * and/or user wants to prevent round-off error when converting a double to an int.
     * @param x Integer in domain of function
     * @return Returns double value
     */
    public double evalFunc(int x){
        funcParser.addVariable(variable,x);
        return funcParser.getValue();
    }
    
    /**
     * Evaluates multi-dimensional function.
     * @param variableVals Double array containing values in the domain for all variables
     * @return Returns double value.
     */
    public double evalFunc(double[] variableVals){
        for (int i=0; i<=dimension-1; i++){
            funcParser.addVariable(variables[i],variableVals[i]);
        }
        return funcParser.getValue();
    }
    
    
    //sometimes want to eval func in this manner.  i don't recommend it
    //you must set useAllVariables=true when parsing strings
    /**
     * Evaluates multi-dimensional function of the form f(t,variableVals).  For example, it is common to 
     * represent a differential equation as y'=f(t,y) where y is a vector.  This method is for convenience as
     * it is certainly possible to utilize evalFunc(double[] variableVals).  
     * useAllVariables should be set to 'true' if using this method.
     * @param t Independent variable, usually representing time.
     * @param variableVals Double array of other independent variables.
     * @return Returns a double value
     */

    public double evalFunc(double t, double[] variableVals) {
        funcParser.addVariable(variable, t);

        for (int i = 0; i <= dimension - 1; i++) {
            funcParser.addVariable(variables[i], variableVals[i]);
        }
        return funcParser.getValue();
    }

    public boolean evalFunc(Complex z, boolean dummyVariable) {//dummyVariable necessary to disginguish from other evalFunc methods with same parameter list
        funcParser.addVariable(variable, z);
        //if (funcParser.getComplexValue().re()==0.0){
        if (funcParser.getValue() == 0.0) {
            return false;
        } else {
            return true;
        }
    }

    public boolean evalFunc(Complex[] z, boolean dummyVariable) {
        for (int i = 0; i <= dimension - 1; i++) {
            funcParser.addVariable(variables[i], z[i]);
        }
        if (funcParser.getValue() == 0.0) {
            return false;
        } else {
            return true;
        }
    }


    /*
     * This method is only being used in kevinTool Probably should put it in a subclass of FunctionParser
     * unique to KevinTool
     */
    public void setVariables(String[] variables, String variable){
        if (this.variables != null) {
            //note that dimension is the dimension of the Complex part of the function.
            //It does not include the integer variable
            for (int i = 0; i <= dimension - 1; i++) {
                funcParser.removeVariable(this.variables[i]);
                //we don't need the following for kevinTool
               /* if (partialDerivParser!=null){
                    for (int j = 0; j <= dimension - 1; j++) {
                        if (partialDerivParser[j] != null) {
                            partialDerivParser[j].removeVariable(this.variables[i]);
                        }
                    }
                }*/
            }
            funcParser.removeVariable(this.variable);
            //We don't need the following for kevinTool
            /*if (partialDerivParser != null) {
                for (int i = 0; i <= dimension - 1; i++) {
                    if (partialDerivParser[i] != null) {
                        partialDerivParser[i].removeVariable(this.variable);
                    }
                }
            }*/
        }

        this.variables=variables;
        this.variable=variable;
        //dimension=variables.length;
        //multiDimensional=true;
        //setUpMultiDimensionalStuff();
        /* for (int i=0; i<=dimension-1; i++){
            funcParser.addVariable(variables[i], 0.0);
         }
        funcParser.addVariable(variable,0.0);*/

    }

    public void setVariables(String complexVariable, String variable){
        funcParser.removeVariable(this.complexVariable);
        funcParser.removeVariable(this.variable);
        derivParser.removeVariable(this.complexVariable);
        derivParser.removeVariable(this.variable);

        this.complexVariable=complexVariable;
        this.variable=variable;

        //funcParser.addVariable(complexVariable,0.0);
        //funcParser.addVariable(variable,0.0);
    }

    public boolean evalFunc(Complex[] complexVariableVals, int variableVal) {
        for (int i = 0; i <= dimension - 1; i++) {
            funcParser.addVariable(variables[i], complexVariableVals[i]);
        }

        funcParser.addVariable(variable, variableVal);

        if (funcParser.getValue() == 0.0) {
            return false;
        } else {
            return true;
        }
    }

    public boolean evalFunc(Complex complexVariableVal, int variableVal) {
        funcParser.addVariable(complexVariable, complexVariableVal);
        funcParser.addVariable(variable, variableVal);

        if (funcParser.getValue() == 0.0) {
            return false;
        } else {
            return true;
        }
    }
    
    
    /**
     * Turns off/on implicit multiplication. If implicity multiplication is on, '2x' means the same as '2*x'
     * @param value Boolean value==true turns on implicit multiplication. Thus '2x' is the same as '2*x'.
     * Boolean value==false turns off implicit multiplication.  Thus '2x' is not recognized as '2*x'.
     */
    public void setImplicitMultiplication(boolean value){
        funcParser.setImplicitMul(value);
        implicitMultiplication=value;
    }
    
    /**
     * Returns value of implicitMultiplication
     * @return Returns boolean value.
     */
    public boolean getImplicitMultiplication(){
        return implicitMultiplication;
    }
    
    /**
     * Sets value of variable
     * @param variable variable represents variable to be used when parsing funcInput
     */
    public void setVariable(String variable){ //must use with 1D functions only
        funcParser.removeVariable(this.variable);
        derivParser.removeVariable(this.variable);
        this.variable=variable;
       // funcParser.addVariable(variable,0.0);
    }
    
    /**
     * Returns value of variable to user.
     * @return Returns String value
     */
    public String getVariable(){
        return variable;
    }
    
    /**
     * Sets the variables array. Used to define which variables are in the domain of the function.
     * @param variables String array of variables.
     */
    public void setVariables(String[] variables){ //must use with multi-dimensional funcs only.
        if (this.variables != null) {
            for (int i = 0; i <= oldDimension - 1; i++) {
                funcParser.removeVariable(this.variables[i]);
                if (partialDerivParser != null) {
                    for (int j = 0; j <= oldDimension - 1; j++) {
                        if (partialDerivParser[j] != null) {
                            partialDerivParser[j].removeVariable(this.variables[i]);
                        }
                    }
                }
            }
        }

        this.variables=variables;
        

  /*      if (dimension>1){
            //setUpMultiDimensionalStuff();
        }
         for (int i=0; i<=dimension-1; i++){
            //funcParser.addVariable(variables[i], 0.0);
         }*/
        
    }
    
    /**
     * Sets variable and variables. These represent the name of the variables used in a multi-dimensional function.
     * Typically, variable='t' and variables is String array representing all other names.
     * @param variable String. Typically variable='t'.
     * @param variables String array representing names of all independent variables excepting variable.
     */
    public void setVariables(String variable, String[] variables){
        funcParser.removeVariable(this.variable);
        if (this.variables != null) {
            for (int i = 0; i <= this.variables.length - 1; i++) {
                funcParser.removeVariable(this.variables[i]);
            }
        }
        this.variable=variable;
        this.variables=variables;
        multiDimensional=false;
        useAllVariables=true;
        
        //dimension=variables.length;
        //setUpMultiDimensionalStuff();
        /*funcParser.addVariable(variable,0.0);
         for (int i=0; i<=dimension-1; i++){
            funcParser.addVariable(variables[i], 0.0);
         }*/
    }
    
    /**
     * Removes variable.  Used primarily in context of funcHasVariable() method.
     * @param variable variable to be removed.
     */
    public void removeVariable(String variable){
        funcParser.removeVariable(variable);
    }
    
    /**
     * Removes all variables. Used primarily in context of funcHasVariable() method.
     * @param variables Removes names of variables in this String array.
     */
    public void removeVariables(String[] variables){
        for (int i=0; i<=variables.length-1; i++){
            funcParser.removeVariable(variables[i]);
        }
    }
    
    /**
     * Removes variable and variables. Used primarily in context of funcHasVariable() method.
     * @param variable String usually representing independent variable 't'
     * @param variables String array holding names of independent variables in multi-dimensional function.
     */
    public void removeVariables(String variable, String[] variables){
        funcParser.removeVariable(variable);
        for (int i=0; i<=variables.length-1; i++){
            funcParser.removeVariable(variables[i]);
        }
    }
    
    /**
     * Getter function returning names of variables in use by function.
     * @return Returns string array.
     */
    public String[] getVariables(){
        return variables;
    }
    
    /**
     * Setter function for variableValue
     * @param variableValue Holds double value of variable.
     */
    public void setVariableValue(double variableValue){
        this.variableValue=variableValue;
    }
    
    /**
     * Getter function for variableValue
     * @return Returns double
     */
    public double getVariableValue(){
        return variableValue;
    }
    
    /**
     * Used to determine if parsing or function evaluation process creates an error.
     * @return Returns boolean.
     */
    public boolean funcHasError(){
        return funcParser.hasError();
    }
    
    /**
     * Getter function for funcErrorInfo.
     * @return Returns String
     */
    public String getFuncErrorInfo(){
        return funcParser.getErrorInfo();
    }
    
    /**
     * Returns 'true' if error created when parsing or evaluating the derivative.
     * @return Returns boolean
     */
    public boolean derivHasError(){
        return derivHasError;
    }
    
    /**
     * Getter function for derivErrorInfo
     * @return Returns String.
     */
    public String getDerivErrorInfo(){
        return derivParser.getErrorInfo();
    }
    
    /**
     * Getter function for whichDeriv.  whichDeriv keeps track of how many derivatives have been computed.
     * whichDeriv==0 at instantiation.
     * @return Returns int.
     */
    public int getWhichDeriv(){
        return whichDeriv;
    }

    //computes another derivative with respect to the var variable
    /**
     *
     * @param var
     */
    public void computeDeriv(int var){
        computeDeriv(var,var);
    }

    //So computeDeriv(0,2) means compute the partial derivative of the current derivative in the  0th placeholder
    //wrt variable 2 (i.e. the 3rd variable).
    //This (sort of) allows user to do mixed partial derivatives.
    //User must keep up with which derivatives have been computed.
    //This solution could use some work.
    //I still need to figure out how to take derivative wrt to 'variable' if usingAllVariables==true
    /**
     *
     * @param variable1
     * @param variable2
     */
    public void computeDeriv(int variable1, int variable2) {
        try {
            partialDerivInput[variable1] = funcParser.toString(funcParser.simplify(funcParser.differentiate(funcParser.parse(partialDerivInput[variable1]), variables[variable2])));
        } catch (ParseException e) {
            partialDerivHasError[variable1] = true;
        }

        if (!partialDerivHasError[variable1]){
            if (useAllVariables) {
                partialDerivParser[variable1].addVariable(variable, 0.0);
            }
            for (int i=0; i<=dimension-1; i++){
                partialDerivParser[variable1].addVariable(variables[i],0.0);
            }
            partialDerivParser[variable1].parseExpression(partialDerivInput[variable1]);
            whichPartialDeriv[variable1]++;
        }
    }
    
    /**
     * Computes derivative from function created via parseExpression.  
     * Updates String derivInput with this information.
     */
    public void computeDeriv(){
        try{
            derivInput=funcParser.toString(funcParser.simplify(funcParser.differentiate(funcParser.parse(derivInput),variable)));
        } catch(ParseException e){
            derivHasError=true;
        }
        if (!derivHasError) {
            derivParser.addVariable(variable, 0.0);
            derivParser.parseExpression(derivInput);
            whichDeriv++;
        }
    }
    
    /**
     * Returns string representing derivative
     * @return Returns String value.
     */
    public String getDeriv(){
        return derivInput;
    }
    
    /**
     * Evaluates real-valued derivative and returns double. If whichDeriv==0, the original function is evaluated. 
     * Otherwise, computeDeriv() must be called to construct the derivative.
     * @param x Location at which to evaluate derivative
     * @return Returns double.
     */
    public double evalDeriv(double x){
        derivParser.addVariable(variable,x);
        return derivParser.getValue();
    }

    /**
     *
     * @param i
     * @param x
     * @param y
     * @return
     */
    public double evalDeriv(int i, double x, double y){
        partialDerivParser[i].addVariable(variables[0],x);
        partialDerivParser[i].addVariable(variables[1],y);

        return partialDerivParser[i].getValue();
    }

     /**
     *
     * @param i
     * @param x
     * @param y
     * @param z
     * @return
     */
    public double evalDeriv(int i, double x, double y, double z){
        partialDerivParser[i].addVariable(variables[0],x);
        partialDerivParser[i].addVariable(variables[1],y);
        partialDerivParser[i].addVariable(variables[2],z);

        return partialDerivParser[i].getValue();
    }

    /**
     *
     * @param i
     * @param variableVals
     * @return
     */
    public double evalDeriv(int i, double[] variableVals){
        for (int j=0; j<=dimension-1; j++){
            partialDerivParser[i].addVariable(variables[j],variableVals[j]);
        }
        return partialDerivParser[i].getValue();
    }
    
    /**
     * Evaluates complex-valued derivative and returns Complex. If whichDeriv==0, the original function is evaluated. 
     * Otherwise, computeDeriv() must be called to construct the derivative.
     * @param z Complex z is location at which to evaluate derivative
     * @return Returns Complex object.
     */
    public Complex evalDeriv(Complex z){
        derivParser.addVariable(variable,z);
        return derivParser.getComplexValue();
    }
    
    /**
     * Evaluates real-valued derivative and returns double. If whichDeriv==0, the original function is evaluated. 
     * Otherwise, computeDeriv() must be called to construct the derivative.
     * @param x Integer x is location in domain at which to evaluate derivative.
     * @return Returns double
     */
    public double evalDeriv(int x){
        derivParser.addVariable(variable,x);
        return derivParser.getValue();
    }
    
    /**
     * Used to test if string funcInput contains testVariable.
     * @param testVariable String containing name of variable.
     * @return Returns boolean.
     */
    public boolean funcHasVariable(String testVariable){
        boolean val=false;
        
        funcParser.removeVariable(testVariable); //guarantees it's not in there from previous calculation
        funcParser.parseExpression(funcInput);
        if (funcParser.getVar(testVariable)!=null){
            val=true;
            funcParser.addVariable(testVariable,0.0);
        }
        
        return val;
    }
    
    /**
     * Setter function for useAllVariables.  This is for special case when needing to use both variable and variables to hold info.
     * @param useAllVariables useAllVariables==true when needing to use both variable and variables to hold info.
     */
    public void setUseAllVariables(boolean useAllVariables){
        this.useAllVariables=useAllVariables;
    }
    
    /**
     * Getter method for useAllVariables
     * @return Returns true using both variable and variables to hold info.
     */
    public boolean getUseAllVariables(){
        return this.useAllVariables;
    }
    
    /**
     * Holds value of property complex.
     */
    protected boolean complex;
    
    /**
     * Getter for property complex.
     * @return Value of property complex.
     */
    public boolean isComplex() {
        return this.complex;
    }
    
    /**
     * Setter for property complex.
     * @param complex New value of property complex.
     */
    public void setComplex(boolean complex) {
        this.complex = complex;
        if (complex){
            funcParser.addComplex();
            derivParser.addComplex();
        }
    }
    
    /**
     * Setter function for funcInput
     * @param funcInput String representing function. This will be parsed when calling parseExpression().
     */
    public void setFuncInput(String funcInput){
        this.funcInput=funcInput;
    }
    
    /**
     * Getter function for funcInput representing function
     * @return Returns string.
     */
    public String getFuncInput(){
        return this.funcInput;
    }
    
    /**
     * Setter method for derivInput. This is used to over-ride derivInput automatically generated whcih calling
     * computeDeriv() method.
     * @param derivInput String holding output from computeDeriv() method or setDerivInput method.
     */
    public void setDerivInput(String derivInput){
        this.derivInput=derivInput;
    }
    
    /**
     * Getter method for derivInput.
     * @return Returns String value.
     */
    public String getDerivInput(){
        return this.derivInput;
    }

    protected String complexVariable = "";

    /**
     * Get the value of complexVariable
     *
     * @return the value of complexVariable
     */
    public String getComplexVariable() {
        return complexVariable;
    }

    /**
     * Set the value of complexVariable
     *
     * @param complexVariable new value of complexVariable
     */
    public void setComplexVariable(String complexVariable) {
        this.complexVariable = complexVariable;
    }

    protected boolean usingPartialDerivs = false;

    /**
     * Get the value of usingPartialDerivs
     *
     * @return the value of usingPartialDerivs
     */
    public boolean isUsingPartialDerivs() {
        return usingPartialDerivs;
    }

    /**
     * Set the value of usingPartialDerivs
     *
     * @param usingPartialDerivs new value of usingPartialDerivs
     */
    public void setUsingPartialDerivs(boolean usingPartialDerivs) {
        this.usingPartialDerivs = usingPartialDerivs;
    }

    
}
