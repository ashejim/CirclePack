package ftnTheory;

import java.io.BufferedReader;
import java.io.File;
import java.util.Iterator;
import java.util.Vector;

import allMains.CPBase;
import allMains.CirclePack;
import circlePack.PackControl;
import complex.Complex;
import exceptions.CombException;
import exceptions.DataException;
import exceptions.InOutException;
import exceptions.ParserException;
import geometry.EuclMath;
import geometry.HyperbolicMath;
import geometry.SphericalMath;
import input.CPFileManager;
import input.CommandStrParser;
import input.FileDialogs;
import komplex.EdgeSimple;
import listManip.EdgeLink;
import listManip.NodeLink;
import listManip.TileLink;
import listManip.VertexMap;
import packing.PackData;
import packing.PackExtender;
import panels.CPScreen;
import posting.PostFactory;
import tiling.SubdivisionRules;
import tiling.Tile;
import tiling.TileBuilder;
import tiling.TileData;
import tiling.TileRule;
import util.CmdStruct;
import util.DispFlags;
import util.StringUtil;
import util.UtilPacket;
import util.ViewBox;

/**
 * Tilings are combinatorial, locally planar patterns of tiles, the
 * tiles being n-gons for n>=1. This extender is for generating,
 * manipulating and displaying tilings via associated circle packings.
 * 
 * The basic combinatorics of a tiling are stored in a 'TileData' 
 * structure, which is a pattern of tiles, each defined by a closed, 
 * counterclockwise chain of vertices, starting with the "principal"
 * vertex, 'vert[0]'.
 * 
 * A common situation involves a family of tilings generated by some
 * finite subdivision rule; see class 'SubdivisionRules'. Calling
 * for some depth of subdivision generates a hierarchy of tilings.
 * This is reflected in the element 'gradedTileData' in 
 * 'canonicalPack.tileData'. If 'packData.tileData' has the deepest
 * level tiling, then it is just a pointer to 'canonical.tileData'.
 * However, 'packData.tileData' may represent some lesser depth in
 * the hierarchy, in which case its 'myTiles' are bare bones clones
 * at one level in the hierarchy and do not contain full hierarchy
 * information. 
 * 
 * A global tiling at a given stratum is defined recursively: the
 * subtilings of the top tiles are found and then pasted together, but
 * those subtilings are pasted together from their subtilings, etc.
 * So one recurses on pasting together tiles until one reaches down to
 * the desired level. It is assumed, in order to do the pastings, that
 * at each stratum, neighboring tiles have edges with the same number
 * of vertices, so they can be pasted. This compatibility is part of
 * the art in defining subdivision rules.
 * 
 * This extender builds the tilings at the full requested depth
 * and creates the associated circle packing as it goes along. It 
 * keeps track of the tilings at all intermediate stages in 
 * 'gradedTileData' as well and it stores all the vertices
 * defining tiles at every stage in the tile's 'augmented' vert list.
 *
 * There are four levels of combinatorial complexity for packings one 
 * can associate with tilings:
 * 
 * (1). The minimal has a vertex for each tile corner and a barycenter
 * vertex for each tile. This is mode=1
 * 
 * (2). Next is the barycentric subdivision, which adds a barycenter 
 * vert to each edge: this is a standard topological barycentric 
 * subdivision of the tiling as a cell complex. This is mode=2.
 * See 'baryize'.
 * 
 * (3). (default) Third is 'bary_refine' of the barycentric subdivision from (2),
 * mode=3. Each face is further subdivided as a hex flower. This parallels 
 * the structure introduced with "dessins" and is realized in 'canonicalPack'
 * for continual reference. Problems in tracing edges (e.g., there are three 
 * shortest complex edges between two tile corners) is taken care of with
 * the 'augmented' vertex lists.
 * 
 * (4) Finally, there may be various refinements of any of these. It tiles
 * are displayed using 'canonicalPack' information; the link between these
 * can be corrupted --- e.g., by swapping indices.
 * 
 * CAUTION: 'canonicalPack' has lots of info: the tiles, dual tiles,
 * quad tiles, white/grey tiles, etc. This has to be generated from
 * the input 'TileData' of tiles alone. This extra info is NOT saved
 * in packing files --- only the original tiles are saved. Thus, to
 * use this extra info one must use the 'ConformalTiling' pack
 * extender. 
 * 
 * When constructing subdivision tilings to some depth d, intermediate
 * tilings are stored in 'tileData.gradedTileData'; see 'set_TD'.
 * Tile 'vert's and 'augVert's are all in terms of circles of the parent 
 * packing. In particular, 'mode' should be set initially, it can't really be
 * reset without regenerating the packing from scratch. 
 * 
 * We create and save 'canonicalPack'; if there is no tiling, then a 
 * packing with TileData can be loaded or a tiling 
 * generated using 'pave'. '|ct| export -c {p}' will export 'canonicalPack'
 * to pack 'p', '|ct| get_canon' will replace parent 'packData'
 * with a copy of 'canonicalPack'.
 * 
 * The aim of this extender is to create/modify tilings, generate
 * new packings which can replace 'packData' or be copied or saved,
 * and generate associated dual and quad tilings.
 * 
 * CAUTION: 'canonicalPack' is fixed after it is formed, but 'packData'
 * or its copy of 'TileData' might be changed. The idea is to use
 * 'canonicalPack', its 'TileData', and 'TileData.gradedTileData'
 * as a base to spawn and modify other tilings. 'put_canon' will 
 * recreate 'canonicalPack'.
 * 
 * @author kstephe2
 *
 */
public class ConformalTiling extends PackExtender {

	PackData canonicalPack;   // holds official 'TileData' and canonical packing
	SubdivisionRules subdivRules;
	public int mode;          // mode 1: simple combinatorics, each n-tile just gets barycenter
							  // mode 2: barycentrically subdivide the n edges also
							  // mode 3: baryentrically subdivide the 2n faces (typical)
	
	// To save recomputation in recursive construction of tilings at various depths, on
	//    reading a rules file, we save the 'TileData' for the subdivision of each
	//    tile type in a vector.
	// 'topTileData(j) has subdivision TileData for tile type j (recall types start at 4).
	Vector<TileData> topTileData;
	// As packings are built 'depthPackings(j)' stores vector of packings for tile type j. 
	//    Thus vec(0) (created on reading in a rules file) is a packing (barycentrically 
	//    subdivided, mode 3) for a single tile of type j; vec(d), if it exists for d>0, 
	//    is a packings for a tile of type j subdivided to level d. During 'build2Depth'
	//    recursion, copy from depthPackings(j)(d) if it exists, else create it for
	//    later use. 
	Vector<Vector<PackData>> depthPackings;
	static int targetDepth;         // used only by 'build2Depth'
	
//	static boolean buildDeBug=true; 
	static boolean buildDeBug=false;

	public ConformalTiling(PackData p) {
		super(p);
		extensionType="CONFORMAL_TILING";
		extensionAbbrev="CT";
		toolTip="'ConfomalTiling' creates/manipulates tilings, particularly subdivision"
				+ "tilings. Tiling data is stored with maximal packing 'canonicalPack' "
				+ "and can be copied to/from and manipulated in the parent packing.";
		registerXType();
		subdivRules=null;
		
		if (running) {
			if (packData.tileData==null || packData.tileData.tileCount<=0) {
				msg("No tiling data in this packing: read tiling data");
				canonicalPack=null;
			}
			else 
				putBary(packData);
			packData.packExtensions.add(this);
		}
		
		mode=3; // default standard: an n tile is 2n barycentrically subdivided triangles
		targetDepth=-1;
	}
	
	public int cmdParser(String cmd,Vector<Vector<String>> flagSegs) {
		Vector<String> items=null;
		
		// ============ subtile ===============
		if (cmd.startsWith("subti")) {

			// first, pick off the tile type
			int type=0;
			try {
				type=Integer.parseInt(flagSegs.remove(0).get(0));
			} catch(Exception ex) {
				errorMsg("usage: {t} [-d {x}] tile type 't', depth 'x'");
				return 0;
			}
			
			// pick off 'mode' choice, if there
			int md=mode;
			Vector<Vector<String>> flgS=new Vector<Vector<String>>(0);
			if (flagSegs!=null && flagSegs.size()>0) {
				for (int j=0;j<flagSegs.size();j++) {
					items=flagSegs.get(j);
					if (items.get(0).startsWith("-d"))
						flgS.add(flagSegs.get(j));
					else if (items.get(0).startsWith("-m")) {
						try {
							md=Integer.parseInt(items.get(1));
							if (md>0 && md<4)
								mode=md;
						} catch (Exception ex) {
							md=mode;
						}
					}
				}
			}
			else
				flgS=flagSegs;
			
			// get started with single tile and current 'mode'
			PackData newData=null;
			if (depthPackings!=null)
				newData=copyDepthPacking(depthPackings,type,0);
			else {
				int tpe=subdivRules.type2Rule.findW(type);
				if (tpe<0)
					Oops("This tiling has only "+subdivRules.type2Rule.size()+" types");
				TileRule trule=subdivRules.tileRules.get(tpe);
				Tile tile=new Tile(trule.edgeCount);
				tile.tileType=type;
				newData=tile.singleCanonical(mode);
			}
			CPScreen cps=packData.cpScreen;
			if (newData==null)
				Oops("Failed to build initial seed.");
			cps.swapPackData(newData,true);
			packData=cps.getPackData();
  		  	packData.tileData.myTiles[1].tileType=type;
  		  	
  		  	// now build subdivision tiling to depth, specified now in 'flgS'
			return cmdParser("build_sub",flgS);
		}

		// ================ set_tlist (set_Tlist) ==============
		//  PackData must have 'TileData'. However, we try to use the
		//    corresponding 'TileData' from canonicalPack if available so
		//    e.g., we can look for 'child' tile indices.
		else if (cmd.startsWith("set_") && cmd.contains("list") ) {
			
			// valid call?
			char c=cmd.charAt(4);
			if (c!='t' && c!='T')
				throw new ParserException("'set_???' call malformed");
			if (packData.tileData==null)
				throw new ParserException("pack has no 'TileData' to use");
			boolean locallist=true;
			if (c=='T')
				locallist=false;
			
			// default to 'all'
			if (flagSegs==null || flagSegs.size()==0 || flagSegs.get(0).size()==0) {
				items=new Vector<String>(0);
				items.add("a");
			}
			else // there should be at most one flag segment
				items=flagSegs.get(0);

			TileData currTD=packData.tileData;
			TileLink nextLink=null;
			
			// -P{n} current tiles whose parents n levels up are in the list
			if (items.get(0).startsWith("-P")) {
				int mxdepth=0;
				int mydepth=0;

				// find maximum depth available
				if (canonicalPack==null || canonicalPack.tileData.gradedTileData==null ||
					(mxdepth=canonicalPack.tileData.gradedTileData.size())==0)
					Oops("No child tiles: 'canonicalPack' has no graded 'TileData'");
				
				// find 'mydepth', the current 'TileData'
				for (int d=0;d<mxdepth;d++) { // can find the corresponding one?
					TileData td=canonicalPack.tileData.gradedTileData.get(d);
					if (currTD.tileCount==td.tileCount) {
						mydepth=d;
					}
				}
				if (mydepth==0) { // greatest depth not in gradedTileData, in 'canonicalPack'
					if (currTD.tileCount!=canonicalPack.tileData.tileCount)
						Oops("We are at most shallow level, no parents available");
					mydepth=mxdepth;
				}
				
				// find parent level to start at
				String str=items.get(0).substring(2);
				int startdepth=mydepth-1;
				if (str.length()>0) {
					try {
						startdepth=Integer.parseInt(str); // read integer, defaults to 1
						if (startdepth<0 || startdepth==mydepth)
							Oops("must start at least one tiling level up");
					} catch(Exception ex) {
						Oops("usage: |ct| set_tlist -P{d} {t...}");
					}
				}
				
				// remove the flag, left with original list {t..}
				items.remove(0);
				
				// initial list of tiles should be from 'startdepth'
				currTD=canonicalPack.tileData.gradedTileData.get(startdepth);
				nextLink=new TileLink(currTD,StringUtil.reconstitute(flagSegs)); 
				TileLink currLink=null;
				for (int d=startdepth;d<mydepth;d++) {
					currTD=canonicalPack.tileData.gradedTileData.get(d);
					currLink=nextLink;
					nextLink=new TileLink(); // throw child indices in here
					Iterator<Integer> ink=currLink.iterator();
					while (ink.hasNext()) {
						int t=ink.next();
						if (t>=1 && t<currTD.tileCount) { // legal index?
							Tile atile=currTD.myTiles[t];
							TileData atd=atile.myTileData;
							if (atd!=null) { // has children?
								for (int cld=1;cld<=atd.tileCount;cld++) {
									nextLink.add(atd.myTiles[cld].tileIndex); // add child's index
								}
							}
						}
					} //while though 'currLink', build 'nextLink'
				} // done with for loop through depths
				if (locallist) {
					packData.tlist=nextLink;
					return packData.tlist.size();
				}
				else { 
					CPBase.Tlink=nextLink;
					return CPBase.Tlink.size();
				}
					
			} // done with special '-P' flag to get children

			if (locallist) { // note: these may be illegal tile numbers until 'TileData' is reset
				packData.tlist=new TileLink(currTD,items);
				return packData.tlist.size();
			}
			else {
				CPBase.Tlink=new TileLink(currTD,items);
				return CPBase.Tlink.size();
			}
		}

		
		// ================ store_eucl ================
		// preparing to draw traditional euclidean tilings --- save the tile
		//   vertex locations: this requires the rule file to have had optional 
		//   eucl position data (perhaps 3D); tile marks are set to depth.
		//   Caution: KData[].center and .rad are modified.
		//   TODO: alternative is to write the info to a file in "eucl3D" 
		//   command, which is under development (1/2018).
		
		if (cmd.startsWith("store_eucl")) {
			if (subdivRules==null ||
					packData.tileData==null || packData.tileData.tileCount<=0)
				throw new ParserException("packing has no 'tileData' or no subdivision rules");
			for (int j=4;j<subdivRules.tileRules.size();j++) 
				if (subdivRules.tileRules.get(j).stdCorners==null)
					throw new ParserException("sub rules don't have optional eucl positions");
			if (canonicalPack==null)
				throw new CombException("canonicalPack is null");
			if (canonicalPack.tileData.gradedTileData==null || 
					canonicalPack.tileData.gradedTileData.get(0).myTiles.length!=2)
				throw new ParserException("for 'store_eucl', there must be just one top level tile");
			
			Tile toptile=canonicalPack.tileData.gradedTileData.get(0).myTiles[1];
			Complex []topbase=new Complex[2];
			TileRule toprule=subdivRules.tileRules.get(toptile.tileType-4);
			topbase[0]=new Complex(toprule.stdCorners[0]);
			topbase[1]=new Complex(toprule.stdCorners[1]);
			
			// initial 'mark's = -1, recursively set to depth; all radii = .025
			for (int v=1;v<=packData.nodeCount;v++) {
				packData.kData[v].mark=-1;
				packData.setRadius(v,0.025);
			}
			
			// go to depth of current subdivision grading
			int depth=0;
			if (canonicalPack.tileData.gradedTileData!=null) {
				depth=canonicalPack.tileData.gradedTileData.size();
			}
	      	
//	      	Complex []initBase=new Complex[2];
//	      	initBase[0]=new Complex(0.0);
//	      	initBase[1]=new Complex(1.0);
	      	int count=setEuclRecurs(packData,subdivRules, toptile,topbase,depth);
	      	if (count==0)
	      		throw new InOutException("failed in setting eucl locations");
      			      	
	      	return count;
		}

		// ================ draw_eucl ==================
		// for drawing traditional euclidean tilings in the plane, with euclidean
		//   centers stored in KData[].center for the tile vertices; must call
		//   'store_eucl' first
		if (cmd.startsWith("draw_eucl")) {

			if (canonicalPack==null)
				throw new CombException("canonicalPack is null");

			DispFlags dispFlags=new DispFlags(null);
			TileLink tileLink=new TileLink(packData.tileData,"a"); // default to all tiles
			int count=0;
			
			// flags '-d {d}' for depth, '-xxx' for displayflags, and 't...' for tiles
			if (flagSegs!=null && flagSegs.size()>0) {
				Iterator<Vector<String>> fit=flagSegs.iterator();
				while (fit.hasNext()) {
					items=fit.next();
					String str=items.get(0);
					if (str.startsWith("-")) { // display flags
						items.remove(0); // toss the flags
						str.substring(1);
						dispFlags=new DispFlags(str,cpScreen.fillOpacity);
					}
					
					// remaining should only be 
					if (items.size()>0) 
						tileLink=new TileLink(packData.tileData,items);
				}
			}

			Iterator<Integer> tlink=tileLink.iterator();
			while (tlink.hasNext()) {
				Tile tile=packData.tileData.myTiles[tlink.next()];
				count+=recurseDrawTile(tile,dispFlags);
			}
			
			PackControl.canvasRedrawer.paintMyCanvasses(packData,false);
			
			return count;
		}
		
		// ================ print eucl ==================
		if (cmd.startsWith("write_eucl")) {
			if (subdivRules==null ||
					packData.tileData==null || packData.tileData.tileCount<=0)
				throw new ParserException("packing has no 'tileData' or no subdivision rules");
			for (int j=4;j<subdivRules.tileRules.size();j++) 
				if (subdivRules.tileRules.get(j).stdCorners==null)
					throw new ParserException("sub rules don't have optional eucl positions");
			
			// Will have just one top level tile; default to first tile type
			// TODO: might add optional user-specified top type
			
			int toptype=packData.tileData.myTiles[1].tileType;
			toptype=canonicalPack.tileData.gradedTileData.get(0).myTiles[1].tileType;
			Complex []topbase=new Complex[2];
			TileRule toprule=subdivRules.tileRules.get(toptype-4);
			topbase[0]=new Complex(toprule.stdCorners[0]);
			topbase[1]=new Complex(toprule.stdCorners[1]);
			
			// tmp screen size: put in cpScreen, then reset later
			double minx=0.0;
			double maxx=1.0;
			double miny=0.0;
			double maxy=0.0;
			for (int j=2;j<toprule.stdCorners.length;j++) {
				Complex cz=toprule.stdCorners[j];
				minx=(cz.x<minx) ? cz.x:minx;
				maxx=(cz.x>maxx) ? cz.x:maxx;
				miny=(cz.y<miny) ? cz.y:miny;
				maxy=(cz.y>maxy) ? cz.y:maxy;
			}
			double len=maxx-minx;
			double leny=maxy-miny;
			len=(leny>len) ? leny:len;
			double margin=(.05)*len;
			Complex lz=new Complex(minx-margin,miny-margin);
			Complex rz=new Complex(minx+len+margin,miny+len+margin);
			
			ViewBox holdVB=packData.cpScreen.realBox;
			ViewBox tmpVB=new ViewBox();
			tmpVB.setView(lz, rz);
			packData.cpScreen.realBox=tmpVB;
			
			// go to depth of current subdivision grading
			int depth=0;
			if (canonicalPack.tileData.gradedTileData!=null) {
				depth=canonicalPack.tileData.gradedTileData.size();
			}
			
	      	// Get and remove trailing filename as first step
			StringBuilder strbld=new StringBuilder();
	      	int fra=CPFileManager.trailingFile(flagSegs, strbld);
	      	String fname=null;
	      	if (fra!=0)
	      		fname=strbld.toString();
	      	else 
	      		fname=new String("eucl_tiling.ps");
	      	
	      	// open a postscript file
	      	if (CommandStrParser.jexecute(packData,new String("post -o "+fname))==0) {
	      		CirclePack.cpb.errMsg("posting of eucl tiles failed");
	      		return 0;
	      	}
	      	PostFactory pF=CommandStrParser.pF;
	      	
	      	Complex []initBase=new Complex[2];
	      	initBase[0]=new Complex(0.0);
	      	initBase[1]=new Complex(1.0);
	      	int count= pF.postTileRecurs(subdivRules, toptype,initBase,depth);
	      	if (count==0)
	      		throw new InOutException("failed posting eucl tiling");

	      	CommandStrParser.jexecute(packData,new String("post -x"));
	      	CirclePack.cpb.msg("posted eucl tiling to "+fname);
	      	packData.cpScreen.realBox=holdVB; // reset the original realBox
      			      	
	      	return count;
		}
		
		
		// ================ set_flowers =====
		else if (cmd.startsWith("set_tf")) { // very unreliable due to unigons, digons, self-pastings
			if (packData.tileData==null || packData.tileData.tileCount<=0)
				throw new ParserException("packing has no 'tileData'");
			return TileData.setTileFlowers(packData.tileData);
		}
		
		// ================ feedback ===========
		else if (cmd.startsWith("feedba")) {

			int depth=0;
			
			// initial checks
			if (canonicalPack.tileData==null)
				throw new ParserException("feedback: 'canonicalPack' has no 'TileData'");
			if (canonicalPack.tileData.gradedTileData!=null)
				depth=canonicalPack.tileData.gradedTileData.size();
			TileData tdata1=canonicalPack.tileData;
			TileData tdata2=canonicalPack.tileData;

			// usage: -d {d} {-f t1 [v1] -t t2 [v2] ...}
			VertexMap fromtoPairs=null;
			try {
				items=flagSegs.remove(0);
				
				// get depth info
				if (!items.remove(0).equals("-d")) 
					throw new ParserException("need to specify depth d, -d flag");
				int d1=Integer.parseInt(items.remove(0));
				if (d1<0 || d1> depth)
					throw new ParserException("given depth, "+d1+" is improper or not available");
				
				// get 'TileData' at appropriate from/to levels
				if (d1==depth)
					tdata1=canonicalPack.tileData;
				else 
					tdata1=canonicalPack.tileData.gradedTileData.get(d1);
				// always feeding back to depth 0, full bdry
				tdata2=canonicalPack.tileData.gradedTileData.get(0);
				
				// now pick off {fj tj} pairs of tiles (i.e., from/to)
				fromtoPairs=new VertexMap();
				while (items.size()>=2) {
					fromtoPairs.add(new EdgeSimple(Integer.parseInt(items.remove(0)),Integer.parseInt(items.remove(0))));
				}
				
				if (fromtoPairs.size()<1) 
					throw new CombException("Didn't get any from/to pairs");

			} catch(Exception ex) {
				throw new ParserException("usage: feedback -d {d} {{f1 t1} {f2 t2} ... {fn tn}}"); 
			}
			
			// now we process the from/to pairs, building a VertAim vector
			Vector<VertAim> feedbackVec=new Vector<VertAim>(0);
			Iterator<EdgeSimple> ftPairs=fromtoPairs.iterator();
			while (ftPairs.hasNext()) {
				EdgeSimple ft=ftPairs.next();
				Tile fromtile=null;
				Tile totile=null;
				try {
					fromtile=tdata1.myTiles[ft.v];
					totile=tdata2.myTiles[ft.w];
				} catch (Exception ex) {
					throw new ParserException("problem getting tiles");
				}
				if (fromtile.vertCount!=totile.vertCount)
					throw new ParserException("feedback problem: tile vertCounts don't match");
			
				// compute bdry angles of augVert vertices in 'fromtile'.
				double []cornerAngles=tileCornerAngles(packData,fromtile);
				
				// match these to augmented bdry vertices of totile
				int M=totile.augVertCount/fromtile.augVertCount;
				Vector<VertAim> newVAs=new Vector<VertAim>(0);
				for (int i=0;i<fromtile.augVertCount;i++)
					newVAs.add(new VertAim(totile.augVert[i*M],cornerAngles[i]));
				
				// only want corner angles associated with boundary vertices
				//    of the parent packing; put them in 'feedbackVec'.
				Iterator<VertAim> va=newVAs.iterator();
				while (va.hasNext()) {
					VertAim vertaim=va.next();
					if (packData.kData[vertaim.vert].bdryFlag!=0) // is it in bdry?
						feedbackVec.add(vertaim);
				}
			}	
					
			// ------------- now we apply these ----------------------
			// 1. We set all boundary aims to 1.0, 
			// 2. get list of bdry verts occuring in feedbackVec, set their aims to 0.
			// 3. accumulate the aims at each bdry vert in this list.
			int []hits=new int[packData.nodeCount+1]; // which ones will be adjusted?
			cpCommand(packData,"set_aim 1.0 b");
			Iterator<VertAim> fbv=feedbackVec.iterator();
			while (fbv.hasNext()) {
				VertAim vertaim=fbv.next();
				hits[vertaim.vert]=1;
				packData.setAim(vertaim.vert,0.0);
			}
			fbv=feedbackVec.iterator();
			int count=0;
			while (fbv.hasNext()) {
				VertAim vertaim=fbv.next();
				packData.setAim(vertaim.vert, packData.getAim(vertaim.vert)+vertaim.aim);
				// may be more than one angle to add in
				count++;
			}
			
			// normalize? I think it should already have turning angle 2*pi
//			NodeLink bdryLink=new NodeLink(packData,"b");
//			Iterator<Integer> blink=bdryLink.iterator();
//			double turning=0.0;
//			while (blink.hasNext()) {
//				int w=blink.next();
//				turning += (Math.PI-packData.getAim(w));
//			}
//			double factor=2.0*Math.PI/turning;
//			blink=bdryLink.iterator();
//			while (blink.hasNext()) {
//				int w=blink.next();
//			    packData.setAim(w,
//			    		packData.getAim(w)*
//			    		(Math.PI+(Math.PI-packData.getAim(w))*factor));
//			}

			return count;
		}
		
		
		// ================= set_mode ===
		else if (cmd.startsWith("set_mode")) {
			try {
				items=flagSegs.get(0);
				mode=Integer.parseInt(items.get(0));
				if (mode!=2 && mode!=3)
					mode=1;
				try {
					// TODO: there may be more cleaning up to do
					if (mode!=canonicalPack.tileData.builtMode)
						canonicalPack.tileData.gradedTileData=null;
				} catch(Exception ex) {}
			} catch(Exception ex) {
				throw new ParserException("usage: ?{query} {t} requires a tile number 't'");
			}
			return 1;
		}
		
		// ================== query about tiles
		else if (cmd.startsWith("?")) {
			String query=cmd.substring(1).trim();
			char c=query.charAt(0);
			int tn=-1;
			try {
				items=flagSegs.get(0);
				tn=Integer.parseInt(items.get(0));
			} catch(Exception ex) {
				throw new ParserException("usage: ?{query} {t} requires a tile number 't'");
			}
			if (packData.tileData==null || tn<1 || tn>packData.tileData.tileCount)
				return 0;
			
			StringBuilder strb=new StringBuilder("Query, tile "+tn+": ");
			
			// various queries
			switch(c) {
			case 'a': // indices and angles at vertices of tile
			{
				Tile tile=packData.tileData.myTiles[tn];
				strb.append("vert angle/PI");
				
				for (int i=0;i<tile.vertCount;i++) {
					int v=tile.vert[i];
					int hit=-1;
					for (int j=0;(j<tile.augVertCount && hit<0);j++)
						if (tile.augVert[j]==v)
							hit=j;
					if (hit<0)
						throw new CombException("corner "+v+" was not in augVert");
					
					// uv,v,dv in ccw order at corner v
					int cwv=tile.augVert[(hit-1+tile.augVertCount)%tile.augVertCount];
					int ccwv=tile.augVert[(hit+1)%tile.augVertCount];
					
					int num=packData.kData[v].num;
					double vrad=packData.getRadius(v);
					double rad1=packData.getRadius(ccwv);
					double rad2=rad1;
					int ccwv_indx=packData.nghb(v, ccwv);
					int indxdiff=(packData.nghb(v, cwv)-ccwv_indx+num)%num;
					int hes=packData.hes;
					double angsum=0.0;
					for (int k=1;k<=indxdiff;k++) {
						rad1=rad2;
						rad2=packData.getRadius(packData.kData[v].flower[(ccwv_indx+k)%num]);
						UtilPacket uP=new UtilPacket();
						if (hes<0) { // hyp
							HyperbolicMath.h_cos_s_overlap(vrad,rad1,rad2,1.0,1.0,1.0,uP);
							angsum+=Math.acos(uP.value);
						}
						else if (hes>0) { // sph
							angsum+=Math.acos(SphericalMath.s_comp_cos(vrad,rad1,rad2));
							
						}
						else { // eucl
							EuclMath.e_cos_overlap(vrad,rad1,rad2,uP);
							angsum+=Math.acos(uP.value);
						}
					}
					
					strb.append("; "+v+"  "+String.format("%." + 8 + "e", angsum/Math.PI));
				} // end of for
				CirclePack.cpb.msg(strb.toString());
				break;
			}
			} // end of cases
			
			return 1;
		}
		
		// ============ set TileData ============
		else if (cmd.startsWith("set_TD")) {

			// no graded tiling data
			if (canonicalPack.tileData.gradedTileData==null) {
				packData.tileData=canonicalPack.tileData;
				TileData.setPackings(packData.tileData,packData);
				return 1;
			}
			
			// else get tiling data of desired depth
			int depth=0;
			try {
				items=flagSegs.get(0);
				String str=items.get(0);
				
				// deprecated: used to require flag "-d".
				if (items.get(0).startsWith("-d")) {
					str=str.substring(2);
					if (str.length()>0) // no space?
						depth=Integer.parseInt(str);
					else
						depth=Integer.parseInt(items.get(1));
				}
				else 
					depth=Integer.parseInt(str);
			} catch(Exception ex) {}
			
			if (depth>=canonicalPack.tileData.gradedTileData.size())
				packData.tileData=canonicalPack.tileData;
			else if (depth>=0)
				packData.tileData=canonicalPack.tileData.gradedTileData.get(depth).copyBareBones();
			TileData.setPackings(packData.tileData,packData);
			return packData.tileData.tileCount;
		}
		
		
		// ============ set type ===========
		else if (cmd.startsWith("set_type")) {
			if (subdivRules==null) {
				errorMsg("no 'subdivRule' is specified");
				return 0;
			}
			if (flagSegs.size()!=2) {
				errorMsg("usage: {x} -t {t ..}");
				return 0;
			}
			int type=Integer.parseInt(flagSegs.get(0).get(0));
			int edgecount=subdivRules.type2Size.findW(type);
			items=flagSegs.get(1);
			if (!StringUtil.isFlag(items.remove(0))) {
				errorMsg("usage: {x} -t {t ..}");
				return 0;
			}
			TileLink tlink=new TileLink(packData.tileData,items);
			Iterator<Integer> tlk=tlink.iterator();
			while (tlk.hasNext()) {
				int t=tlk.next();
				Tile tile=packData.tileData.myTiles[t];
				if (tile.vertCount!=edgecount) {
					errorMsg("some tiles have wrong vertCount for type "+type);
					return 0;
				}
			}
			tlk=tlink.iterator();
			int count=0;
			while (tlk.hasNext()) {
				packData.tileData.myTiles[tlk.next()].tileType=type;
				count++;
			}
			return count;
		}
		
		// ============ build_sub ==========
		else if (cmd.startsWith("build_sub")) {
			if (packData.tileData==null) {
				errorMsg("no 'TileData'");
				return 0;
			}
			if (packData.tileData.subRules==null) {
				if (subdivRules==null) {
					errorMsg("no 'subRules' and no 'subdivRule' specified");
					return 0;
				}
				
				// inherit 'subdivRules'
				else
					packData.tileData.subRules=subdivRules;
			}
			
			// depth gives the number of recursions; 0 means do no subdivisions.
			// In any case, end up replacing 'packData' with the cannonical packing
			//   for the given level of subdivisions. Also have the various TileData
			//   for subtiles at various levels which are built up to give 'packData'.
			int depth=0; // default = no subdivision (get cannonical packing for 'TileData')
			Iterator<Vector<String>> fsegs=flagSegs.iterator();
			while (fsegs.hasNext()) {
				items=fsegs.next();
				String str=items.get(0);
				if (StringUtil.isFlag(str)) {
					items.remove(0);
					char c=str.charAt(1);
					switch(c) {
					case 'd': // given depth
					{
						if (str.length()>2)
							depth=Integer.parseInt(str.substring(2));
						if (items.size()>0)
							depth=Integer.parseInt(items.get(0));
						if (depth<0)
							Oops("depth negative ???");
						if (depth>50) {
							msg("recuvsive depth limited to 50");
							depth=5;
						}
						break;
					}
					} // end of switch
					
				}
			} // end of while and flag processing
				
			// create the parent packing
			
			// first build 'newPD', with 'newPD.tileData' equal to the
			//     original tileData (though with additional pointers to subtilings)
			targetDepth=-1;
			PackData newPD=build2Depth(packData.tileData,depth,mode,topTileData,depthPackings);
			if (newPD==null) {
				errorMsg("failed to build subdivided packing to depth "+depth);
				targetDepth=-1;
				return 0;
			}
			targetDepth=-1;
			
			// now generate the consolidated 'TileData' structures
			TileData deepestTD=consolidateTiling(newPD.tileData,depth);
			if (depth>0) {
				deepestTD.gradedTileData=new Vector<TileData>(depth);
				for (int d=0;d<depth;d++)
					deepestTD.gradedTileData.add(consolidateTiling(newPD.tileData,d));
			}
			else
				deepestTD.gradedTileData=null;
			
			// put new packing into canonicalPack
			newPD.tileData=null;
			canonicalPack=newPD.copyPackTo();
			canonicalPack.set_aim_default();
			
			// TODO: this can fail until C code is fixed
//			if (cpCommand(canonicalPack,"max_pack")<=0) 
//				errorMsg("failed in max packing new canonicalPack");
//			else
				msg("'canonicalPack' is set");
				
			// copy into 'packData' without 'TileData'
			swapPackData(canonicalPack); 
			
			// 'canonicalPack' will hold the full 'TileData' tree.
			canonicalPack.tileData=deepestTD;
			deepestTD.packData=canonicalPack;
			
			// 'packData' will get a bare-bones copy of the deepest TileData
			packData.tileData=deepestTD.copyBareBones();
			packData.tileData.packData=packData;

			// if top is a single tile, set_vlist to its 'vert's
			if (canonicalPack.tileData.gradedTileData!=null && 
					canonicalPack.tileData.gradedTileData.get(0).tileCount==1) {
				Tile tile=canonicalPack.tileData.gradedTileData.get(0).myTiles[1];
				packData.vlist=new NodeLink(packData);
				for (int j=0;j<tile.vertCount;j++)
					packData.vlist.add(tile.vert[j]);
			}
			else if (canonicalPack.tileData!=null && canonicalPack.tileData.tileCount==1) {
				Tile tile=canonicalPack.tileData.myTiles[1];
				packData.vlist=new NodeLink(packData);
				for (int j=0;j<tile.vertCount;j++)
					packData.vlist.add(tile.vert[j]);
			}
			
			return packData.nodeCount;
		}

		// ============ subtile vertlist =============
		else if (cmd.startsWith("stvl")) {
			if (canonicalPack.tileData==null || canonicalPack.tileData.gradedTileData==null) {
				errorMsg("No 'canonicalPack' or no subdivision tilingsrules in place");
				return 0;
			}
			
			if (flagSegs==null || flagSegs.size()==0) {
				errorMsg("usage: stvl t -n, 't' tile number, 'n' number of generations above it");
				return 0;
			}

			items=flagSegs.get(0);
			int tileno=Integer.parseInt(items.get(0));
			if (tileno<1 || tileno>canonicalPack.tileData.tileCount) {
				errorMsg("improper tile number: "+tileno);
				return 0;
			}
			Tile tile=canonicalPack.tileData.myTiles[tileno];
			int n=Math.abs(Integer.parseInt(items.get(1)));
			NodeLink thelist=new NodeLink(packData);
			
			// search upward at most n levels
			boolean deadend=false;
			int tick=n;
			while (!deadend && tick>0) {
				tick--;
				if (tile.TDparent==null) 
					deadend=true;
				else
					tile=tile.TDparent.parentTile;
			}
			
			if (n==0 || !deadend) {
				if (tile.augVert!=null)
					for (int j=0;j<tile.augVertCount;j++)
						thelist.add(tile.augVert[j]);
				else
					for (int j=0;j<tile.vertCount;j++)
						thelist.add(tile.vert[j]);
			}

			packData.vlist=thelist;
			return packData.vlist.size();
		}
		
		// ============ load_rules ===========
		else if (cmd.startsWith("load_ru")) {
			boolean script_flag=false;
			File theFile=null;
			File dir=CPFileManager.PackingDirectory;
			
			// check for given filename
			StringBuilder sbld=new StringBuilder();
			int info=CPFileManager.trailingFile(flagSegs,sbld);
			String filename=null;
			if (info!=0) {
				if ((info & 01) == 01 || (info & 04)==04) {
					filename=sbld.toString();
				}
				if ((info & 04)==04)
					script_flag=true;
			}
			
			if (filename!=null && filename.length()>0) {
				theFile=new File(filename);
				try {
					dir=new File(theFile.getParent());
				} catch(Exception ex) {
					dir=CPFileManager.PackingDirectory;
				}
			}
			
			if (theFile==null)
				theFile=FileDialogs.loadDialog(FileDialogs.SUBRULEFILE,true);
			
			if (theFile!=null) {
				
				try {
					BufferedReader tfp=SubdivisionRules.getBufferedReader(dir, theFile.getName(), script_flag);
					subdivRules=SubdivisionRules.readRulesFile(tfp,theFile.getName());
					depthPackings=new Vector<Vector<PackData>>(5); // recall type starts at 4
					
					// store a packing (depth 0) for each tile type
					Iterator<TileRule> rls=subdivRules.tileRules.iterator();
					while (rls.hasNext()) {
						TileRule trule=rls.next(); // TODO: rules <-> types currently in 1-to-1 corres.
						Tile tile=new Tile(trule.edgeCount);
						tile.tileType=trule.targetType;
						PackData tmpPD=tile.singleCanonical(mode); 
						
						Vector<PackData> vecpd=new Vector<PackData>(2);
						vecpd.setSize(1);
						vecpd.setElementAt(tmpPD,0);
						if (depthPackings.size()<=tile.tileType)
							depthPackings.setSize(tile.tileType+1);
						depthPackings.setElementAt(vecpd,tile.tileType);
					} // end of while
					
					// store TileData for subdivision of each tile type
					topTileData=new Vector<TileData>(5);
					rls=subdivRules.tileRules.iterator();
					while (rls.hasNext()) {
						TileRule trule=rls.next(); // TODO: rules <-> types currently in 1-to-1 corres.
						TileData tdata=SubdivisionRules.getRulesTD(trule,subdivRules.type2Size,mode);
						if (topTileData.size()<=trule.targetType)
							topTileData.setSize(trule.targetType+1);
						topTileData.setElementAt(tdata,trule.targetType);
					} // end of while

				} catch (Exception ex) {
					throw new ParserException("'load_ru' failed: "+ex.getMessage());
				}
				
				if (subdivRules==null) {
					throw  new ParserException("'load_ru' failed somehow");
				}
				
				return 1;
			}
			return 0;
		}
		
		// =========== test new code ==========
		else if (cmd.startsWith("test")) {
			
			if (subdivRules==null) 
				throw new ParserException("'load_rules' for subdivision rules first");
			
			if (flagSegs==null) {
				throw new ParserException("need tile type");
			}
			items=flagSegs.get(0);
			int tt=Integer.parseInt(items.get(0));
			int ruleIndx=subdivRules.type2Rule.findW(tt);
			// not found? default to use tt as entry number
			if (ruleIndx<=0) {
				tt=Math.abs(tt);
				if (tt<subdivRules.type2Rule.size())
					ruleIndx=tt;
				else 
					ruleIndx=0;
			}
			packData.tileData=SubdivisionRules.getRulesTD(subdivRules.tileRules.get(tt),subdivRules.type2Size,mode);
			cpCommand("write_til -f testTile.q");
			putBary(packData); // create cannonicalPack
			swapPackData(canonicalPack); // copy into packData
//			packData.geom_to_e();
			int N=subdivRules.type2Size.findW(tt+4); // types start at 4
			cpCommand("geom_to_e");
			cpCommand("set_aim 1.0 b");
			cpCommand("set_aim "+(1-2/((double)N))+" a(1 "+N+")");
			cpCommand("rld");
			return cpCommand("Disp -w -c -T");
		}
		
		// ============ mark ================
		else if (cmd.startsWith("mark")) {
			int count=0;
			if (canonicalPack==null)
				return 0;
			for (int v=1;v<=packData.nodeCount;v++) {
				if (v<=canonicalPack.nodeCount) {
					packData.kData[v].mark=canonicalPack.kData[v].mark;
					count++;
				}
				else  
					packData.kData[v].mark=0;
			}
			return count; 
		}
		
		// ============= Vlist =================
		else if (cmd.startsWith("Vlis")) {

			if (canonicalPack==null)
				return 0;

			// can list barycenters or tile vertices
			boolean wantverts=false; 
			int mode=1; // mode: 1=tiles (default), 2=dual tiles, 3=quad tiles
			NodeLink list=null;
			int count=0;
			
			// get info
			Iterator<Vector<String>> fs=flagSegs.iterator();
			while (fs.hasNext() && (items=fs.next())!=null && items.size()>0) {
				String str=items.get(0);

				// look for flags
				if (StringUtil.isFlag(str) && str.length()>1) {
					items.remove(0);
					char c=str.charAt(1);

					// followed by 'v' (in 'T' case only)? then want vertices vs barycenters
					if (str.length()>2 && str.charAt(2)=='v') 
						wantverts=true;

					// flags
					switch(c) {
					case 'T': // tile
					{
						mode=1;
						break;
					}
					case 'D': // dual
					{
						mode=2;
						break;
					}
					case 'Q': // quad
					{
						mode=3;
						break;
					}
					} // end of switch
					
					
				} // done with flags
			
				// after flags, the rest should be a list on indices
				list=new NodeLink(canonicalPack,items);
				
				if (list==null || list.size()==0) 
					return 0;
			}
				
			NodeLink outlist=new NodeLink(packData);
				
			if (mode==2 && canonicalPack.tileData.dualTileData==null)
				throw new DataException("dual tiling data not available");
			if (mode==3 && canonicalPack.tileData.quadTileData==null)
				throw new DataException("quad tiling data not available");
			
			// go through the list
			Iterator<Integer> bvl=list.iterator();
			while (bvl.hasNext()) {
				
				// get the associated tile, if there is one
				Tile tile=null;
				int t=bvl.next();
				if (mode==1)
					tile=canonicalPack.tileData.amIaTile(t);
				else if (mode==2) 
					tile=canonicalPack.tileData.dualTileData.amIaTile(t);
				else if (mode==3)
					tile=canonicalPack.tileData.quadTileData.amIaTile(t);
					
				if (tile==null) {
					continue;
				} // continue

				if (wantverts) {
					for (int j=0;j<tile.vertCount;j++)
						outlist.add(tile.vert[j]);
				}
				else 
					outlist.add(tile.baryVert);
				count++;
			} // end of while

			if (count>0)
				CPBase.Vlink=outlist;
			return count;
		}
		
		// ============= disp ================
		else if (cmd.startsWith("disp") || cmd.startsWith("Disp")) {
			if (flagSegs==null || flagSegs.size()==0) 
				return cpCommand("disp -wr");
			TileData targetTiling=packData.tileData; // default to 'tileData'
			if (packData.tileData==null || packData.tileData.tileCount==0) {
				targetTiling=canonicalPack.tileData;
			}
			if (targetTiling==null)
				return 0;

			int count=0;
			
			Iterator<Vector<String>> fs=flagSegs.iterator();
			while (fs.hasNext() && (items=fs.next())!=null && items.size()>0) {
				String str=items.get(0);
				boolean greyflag=false;
				String specs="";  // disp flags
				int mode=1; // mode: 1=tiles (default), 2=dual tiles, 
							// 3=quad tiles, 4=tile augmented edges
						
				// look for flags, get 'specs' for options
				if (StringUtil.isFlag(str) && str.length()>1) {
					items.remove(0);
					char c=str.charAt(1);
					if (c=='g') {
						greyflag=true;
						if (str.length()==2) { // no
							this.errorMsg("faulty 'disp' flags");
							return 0;
						}
						c=str.charAt(2);
						specs=str.substring(3);
					}
					else 					
						specs=str.substring(2);
					if (specs==null || specs.length()==0)
						specs="";
					
					// flags
					switch(c) {
					case 'D': // dual tiles
					{
						if (packData.tileData.dualTileData!=null)
							targetTiling=packData.tileData.dualTileData;
						else if (canonicalPack.tileData.dualTileData!=null) // dual tiles
							targetTiling=canonicalPack.tileData.dualTileData;
						else 
							throw new DataException("dual tiling data not available");
						mode=2;
						break;
					}
					case 'Q': // quad tiles
					{
						if (packData.tileData.quadTileData!=null)
							targetTiling=packData.tileData.quadTileData;
						else if (canonicalPack.tileData.quadTileData!=null) // quad tiles
							targetTiling=canonicalPack.tileData.quadTileData;
						else 
							throw new DataException("quad tiling data not available");
						mode=3;
						break;
					}
					case 'E': // marked tile edges (for 'tileData')
					{
						mode=4;
						break;
					}
					case 'm': // marked tile corner
					{
						mode=5;
						break;
					}
					} // end of switch
					
				} // done with flags
				
				// process 'specs' for display flags
				DispFlags df=new DispFlags(specs);
				
				// handle marked edge: -E{specs} -m{m} {t..}
				if (mode==4) {
					if (!fs.hasNext()) 
						Oops("usage: disp -E{specs} -m{x} {t..}");
					items=fs.next();
					str=items.remove(0);
					int mark=0;
					if (!str.startsWith("-m") || str.length()<3)
						Oops("usage: disp -E{specs} -m{x} {t..}");
					try {
						mark=Integer.parseInt(str.substring(2)); // contiguous characters
					} catch(Exception ex) {
						Oops("didn't get the edge mark");
					}
					
					TileLink tlist=null;
					if (items.size()==0)
						tlist=new TileLink(targetTiling,"a");
					else
						tlist=new TileLink(targetTiling,items);
					
					Iterator<Integer> tlk=tlist.iterator();
					while (tlk.hasNext()) {
						Tile tile=null;
						int tindx=tlk.next();
						try {
							tile=packData.tileData.myTiles[tindx];
						} catch(Exception ex) {
							Oops("illegal tile number "+tindx);
						}
						TileRule tr=subdivRules.tileRules.get(subdivRules.type2Rule.findW(tile.tileType));
						for (int e=0;e<tr.edgeCount;e++) {
							if(tr.edgeRule[e].mark==mark) {
								EdgeLink elink=EdgeLink.verts2edges(packData,tile.findAugEdge(e),true);
								StringBuilder strb=new StringBuilder("disp -e"+df.reconstitute()+" ");
								Iterator<EdgeSimple> elk=elink.iterator();
								while (elk.hasNext()) {
									EdgeSimple edge=elk.next();
									strb.append(edge.v+" "+edge.w+" ");
								}
								count += cpCommand(packData,strb.toString());
							}
						}
					} // end of while through tiles
					return count;
				} // end of mode=4 (edges)
				
				else if (mode==5) { // first corner of specified tile (i.e. designated one) 
					TileLink tlist=new TileLink(targetTiling,items);
					StringBuilder strb=new StringBuilder("disp -e -t1f ");
					Iterator<Integer> tlk=tlist.iterator();
					while (tlk.hasNext()) {
						try {
							strb.append(targetTiling.myTiles[tlk.next()].vert[0]+" ");
						} catch(Exception ex) {
							Oops("illegal tile index, or missing marked corner");
						}
					};
					count +=cpCommand(packData,strb.toString());
				}
				
				// else, get indices of tiles to draw
				TileLink tlist=new TileLink(targetTiling,items);
				
				// nothing to draw?
				if (tlist==null || tlist.size()==0)
					return 0;

				// draw tiles 
				// TODO: mode 1, 2, 3 ?? etc.
//				NodeLink barylist=null;
//				if (mode==1) { // convert tile index list to baryVert list
//					barylist=new NodeLink(packData);
//					Iterator<Integer> blst=barylist.iterator();
//					while (blst.hasNext()) {
//						int bl=blst.next();
//						if (bl>0 && bl<=canonicalPack.tileData.tileCount)
//							barylist.add(canonicalPack.tileData.myTiles[bl].baryVert);
//					}
//				}
				
				// go through the list
				Iterator<Integer> bvl=tlist.iterator();
				while (bvl.hasNext()) {
					
					int t=bvl.next();
					Tile tile=targetTiling.myTiles[t];
					if (tile==null) {
						continue;
					} // continue
						
					// want greywhite
					else if (greyflag) {
						try {
							int nm=tile.wgIndices.length;
							
							// draw grey first, then white to get good boundaries
							for (int wg=0;wg<2;wg++) {
								if (wg==0) {
									df.fill=true;
									df.setColor(CPScreen.coLor(230)); // light grey (may use or not)
								}
								else {
									df.fill=false;
									df.setColor(null);
								}
								for (int m=0;m<nm;m++) {
									Tile tle=canonicalPack.tileData.wgTiles[tile.wgIndices[m]];
									if ((tle.mark==-1 && wg==0) || (tle.mark==1 && wg==1)) // grey
										count+=cpCommand(packData,"disp -s"+df.reconstitute()+
												" "+tle.tileBorderLink().toString());
								}
							}
						} catch(Exception ex){
							throw new DataException("Problem accessing 'wgTiles' for white/grey tiles");
						}
					}
					else { // not greywhite
						
						StringBuilder flwr=new StringBuilder("");
						
						// if augmented, use augVerts
						if (tile.augVert!=null) {
							for (int j=0;j<tile.augVertCount;j++) 
								flwr.append(tile.augVert[j]+" ");
							flwr.append(tile.augVert[0]);
						}
						
						// else get flower as a string (both corner and edge barycenters)
						else {
							int []flowr=canonicalPack.kData[tile.baryVert].flower;
							for (int j=0;j<=canonicalPack.kData[tile.baryVert].num;j++)
								flwr.append(flowr[j]+" ");
						}
						
						// draw: if 
						if ((df.fill || df.colBorder) && df.getColor()==null) {
							if (tile.color!=null)
								df.setColor(CPScreen.cloneColor(tile.color));
							else if (canonicalPack.kData[tile.baryVert].color!=null)
								df.setColor(CPScreen.cloneColor(canonicalPack.kData[tile.baryVert].color));
							count += cpCommand(packData,"disp -s"+df.reconstitute()+" "+flwr.toString());
							df.setColor(null);
						}
						else 
							count += cpCommand(packData,"disp -s"+df.reconstitute()+" "+flwr.toString());
						if (df.label) { // want label
							packData.cpScreen.drawIndex(packData.getCenter(tile.baryVert), tile.tileIndex, 1);
						}
					}
				} // end of while
			} // end of while through flag sequences
			return count;
		}
		
		// ============= read_bary ============
		else if (cmd.startsWith("read_bary")) {
			
		}

		else if (cmd.startsWith("mid_list")) {
			
		}

		else if (cmd.startsWith("bc_list")) {
			
		}

		// ============= get_canonical ===========
		else if (cmd.startsWith("get_can")) {
			// copy 'canonicalPack' to 'packData'
			if (canonicalPack==null) {
				errorMsg("no 'canonicalPack'");
				return 0;
			}
			
			return swapPackData(canonicalPack);
		}
		
		// ============= put_canonical ===========
		else if (cmd.startsWith("put_can")) {
			// copy 'packData' to 'canonicalPack'
			return putBary(packData);
			
		}
		
		// ============ export ============
		else if (cmd.startsWith("export")) { // preempts PackExtender call
			try {
				items=(Vector<String>)flagSegs.get(0);
				String str=items.get(0);
				
				PackData exportSrc=canonicalPack; // default to 'canonicalPack'
				if (StringUtil.isFlag(str)) {
					items.remove(0);
					switch(str.charAt(1)) {
					case 'm': // minimal
					{
						exportSrc=TileData.tiles2packing(canonicalPack.tileData);
						break;						
					}
					case 'b': // barycentric subdivision of canonical
					{
						exportSrc=canonicalPack.copyPackTo();
						cpCommand(exportSrc,"bary_refine");
						break;
					}
					case 'd': // subdivision rule tree depth; 0 is original tiling
						// format "-d5" for depth 5.
					{
						if (canonicalPack.tileData==null)
							Oops("'canonicalPack' has not 'tileData'");
						int depth=0;
						try {
							depth=Integer.parseInt(str.substring(2)); 
						} catch(Exception ex) {}

						if (depth>0 && canonicalPack.tileData.gradedTileData==null)
							Oops("'canonicalPack' doesn't have 'gradedTileData'");
						if (depth>canonicalPack.tileData.gradedTileData.size()-1)
							depth=canonicalPack.tileData.gradedTileData.size()-1;
						TileData holdTD=canonicalPack.tileData.gradedTileData.get(depth).copyBareBones();
						
						int pnum=Integer.parseInt((String)items.get(0));
						CPScreen cpS=CPBase.pack[pnum];
						if (cpS!=null) {
							TileData tmpTD=canonicalPack.tileData;
							canonicalPack.tileData=null;
							PackData p=canonicalPack.copyPackTo();
							p.tileData=holdTD;
							canonicalPack.tileData=tmpTD;
							return cpS.swapPackData(p,false);
						}
						
						break;
					}
					} // end of switch
				}
				
				int pnum=Integer.parseInt((String)items.get(0));
				CPScreen cpS=CPBase.pack[pnum];
				if (cpS!=null) {
					PackData p=exportSrc.copyPackTo();
					cpCommand(p,"max_pack");
					return cpS.swapPackData(p,false);
				}
			} catch (Exception ex) {
				Oops("'export' problems");
			}
			return 0;
		}
		
		// ============ pave (OBE: pass to regular processing)
		else if (cmd.startsWith("pave")) {
			String addstr="pave ";
			if (flagSegs!=null && flagSegs.size()>0) {
				addstr=new String("pave "+StringUtil.reconItem(flagSegs.get(0)));
			}
			return cpCommand(packData,addstr);
		}
		
		// ============= split ==========
		else if (cmd.startsWith("split3")) {
			if (packData==null || packData.tileData==null || packData.tileData.tileCount==0) {
				errorMsg("'packData' does not have tile data");
				return 0;
			}
			
			PackData workPack=trilize(packData.tileData);
			boolean put_bp=false;
			try {
				items=flagSegs.get(0);
				if (items.get(0).contains("x"))
					put_bp=true;
			} catch(Exception ex) {}
			int ans=swapPackData(workPack);
			if (ans>0 && put_bp)
				return putBary(packData);
			return packData.nodeCount; 
		}

		// ============= godual ==========
		else if (cmd.startsWith("godual")) {
			if (packData==null || packData.tileData==null || packData.tileData.tileCount==0) {
				errorMsg("parent packing does not have tile data");
				return 0;
			}
			boolean put_bp=false;
			try {
				items=flagSegs.get(0);
				if (items.get(0).contains("x"))
					put_bp=true;
			} catch(Exception ex) {}
			int ans=swapPackData(getMyDual(packData.tileData));
			if (ans<=0)
				return 0;
			if (put_bp)
				return putBary(packData);
			return packData.nodeCount; 
		}

		// ============== subdivide ==========
		else if (cmd.startsWith("subd")) {
//		else if (cmd.startsWith("quad") || cmd.startsWith("pent") ||
//				cmd.startsWith("twist") || cmd.startsWith("star")) {
			
			if (canonicalPack==null) {
				Oops("'canonicalPack' must be set, see 'put_bary'");
			}

			char c='z'; // default to no action
			
			// read character to determine type; eat flag '-'.
			try {
				items=flagSegs.get(0);
				c=items.get(0).charAt(0);
				if (c=='-')
					c=items.get(0).charAt(1);
			} catch (Exception ex) {
				Oops("need letter indicating 'subdivision' type");
			}
			
			PackData workPack=null;
			switch(c) {
			case 'b': // barycentric subdivision
			{
				workPack=baryize(canonicalPack.tileData);
				break;
			}
			case 'q': // quad subdivision
			{
				workPack=quaditize(canonicalPack.tileData);
				break;
			}
			case 'p': // pent subdivision
			{
				workPack=pentatize(canonicalPack.tileData);
				break;
			}
			case 't': // twisted subdivision; 'cr' means twist right
			{
				if (items.get(0).contains("cr")) 
					workPack=twistize(canonicalPack,true);
				else 
					workPack=twistize(canonicalPack,false);
				break;
			}
			case 's': // star subdivision
			{
				workPack=starize(canonicalPack.tileData);
				break;
			}
			case 'h': // hex subdivision
			{
				workPack=hexize(canonicalPack.tileData);
				break;
			}
			case 'd': // delta subdivision
			{
				workPack=deltize(canonicalPack.tileData);
				break;
			}
			} // end of switch
			
			if (workPack!=null) {
				int ans=swapPackData(workPack);
				if (ans>0)
					return putBary(packData);
				return packData.nodeCount; 
			}
			return 0;
		}
		
		// else default to superclass
		return super.cmdParser(cmd,flagSegs);
	}

	/**
	 * Replace 'canonicalPack' by the barycentric packing
	 * generated by the tiling of 'p'.
	 * @param p PackData
	 * @return nodeCount or 0 on error or if p has no tiles
	 */
	public int putBary(PackData p) {
		if (p==null || p.tileData==null || p.tileData.tileCount<=0) {
			return 0;
		}
		
		// try the new code, 7/2014, else revert to the old		
		try {
			TileBuilder tileBuilder=new TileBuilder(p.tileData);
			PackData np=tileBuilder.fullfromFlowers();
			if (np==null || np.tileData==null || np.nodeCount<=0)
				throw new CombException("'tileBuilder' seems to have failed");
			if (TileBuilder.prepCanonical(np)<=0)
				throw new CombException("'prepCanonical' seems to have failed");
			canonicalPack=np;
		} catch(Exception ex) {
			try {
				CirclePack.cpb.errMsg("'TileBuilder' has failed, try 'tiles2FullBary'");
				canonicalPack=TileData.tiles2FullBary(p.tileData);
			} catch (Exception exe) {				
				throw new ParserException("both 'TileBuilder' and 'tiles2FullBary failed: "+exe.getMessage());
			}
		}
		
		try {
			cpCommand(canonicalPack,"layout -F");
			if (cpCommand(canonicalPack,"max_pack")<=0) 
				errorMsg("failed in max packing new canonicalPack");
			else
				msg("'canonicalPack' is set");
			return canonicalPack.nodeCount;
		} catch(Exception ex) {
			throw new CombException("problem in canonicalPack layout or max_packing ");
		}
	}
	

	/**
	 * Given TileData, create a new packing by splitting every 
	 * tile edge with two new vertices. The vertex 'mark's in the 
	 * new packing are set to {1,2,3,4} for {tile baryVert,original 
	 * tile vert, newvert1, newvert2}, in order.
	 * @param td TileData
	 * @return PackData, null on error
	 */
	public static PackData trilize(TileData td) {

		// do we have tiles?
		if (td==null || td.tileCount<=0) {
			return null;
		}
		
		PackData newPD=TileData.tiles2packing(td);
		
		// (over)count the edges
		int ecount=0;
		for (int t=1;t<=td.tileCount;t++)
			ecount+=td.myTiles[t].vertCount;
		newPD.alloc_pack_space(newPD.nodeCount+2*ecount,true);
		newPD.tileData=td.copyMyTileData();
		
		// clear 'mark's
		for (int i=1;i<=newPD.nodeCount;i++)
			newPD.kData[i].mark=0;

		// go through tiles, split edges, set marks
		//    splitting edge should prevent it being split again
		//    from the other side
		for (int t=1;t<=newPD.tileData.tileCount;t++) {
			Tile tile=newPD.tileData.myTiles[t];
			newPD.kData[tile.baryVert].mark=1;
			int w=tile.vert[0];
			newPD.kData[w].mark=2;
			int v=w;
			for (int j=1;j<=tile.vertCount;j++) {
				v=w;
				if (j==tile.vertCount)
					w=tile.vert[0];
				else 
					w=tile.vert[j];
				newPD.kData[w].mark=2;
				int v1=newPD.split_edge(v,w);
				if (v1!=0) { // if you add one
					newPD.kData[v1].mark=4;
					int v2=newPD.split_edge(v,v1); // then add a second
					if (v2!=0)
						newPD.kData[v2].mark=3;
				}
			}
		}
		
		newPD.setCombinatorics();
		return newPD;
	}
	
	/**
	 * Create a new barycentric packing using 'TileData', but then reset
	 * its 'tileData' to reflect the dual tiling. This way, the packing 
	 * is unchanged. 
	 * 
	 * One problem is convention for boundary edges: dual's are 'half'ed: 
	 * boundary tiles are closed up with boundary edges, so the dual to 
	 * a boundary edge ends at a "corner" of the dual tile, the vertex
	 * associated with the dual tile (a corner in the origin) is a 
	 * corner. NOTE: building a packing from the dual will add barycenters
	 * to these half tile, hence change the combinatoric; so dual of the
	 * dual is not quite the original.
	 * @param td TileData
	 * @return PackData, null if there's no tiling information
	 */
	public PackData getMyDual(TileData td) {

		// is there tile data?
		if (td==null || td.tileCount<=0) {
			return null;
		}

		PackData dualPD=TileData.tiles2FullBary(td);
		if (dualPD==null) {
			errorMsg("failed in generating the packing for dualizing");
			return null;
		}
		dualPD.tileData=dualPD.tileData.dualTileData.copyMyTileData();
		dualPD.tileData.quadTileData=null;
		dualPD.tileData.dualTileData=null;
		return dualPD;
	}
	
	
	/**
	 * Create a packing with the quad tiling associated to given
	 * TileData. Note: this has 'half' tiles along the boundary, ones
	 * whose baryVert's are bdry vertices. Thus, the packing returned
	 * here is slightly different than that that would be created for
	 * this tiling -- i.e., where those bdry tiles would get new baryVerts 
	 * @param td TileData
	 * @return new PackData
	 */
	public PackData quaditize(TileData td) {

		// is there tile data?
		if (td==null || td.tileCount<=0) {
			return null;
		}

		PackData newPD=TileData.tiles2packing(td);
		newPD.tileData=newPD.tileData.quadTileData.copyMyTileData();
		newPD.tileData.dualTileData=null;
		newPD.tileData.quadTileData=null;
		return newPD;
	}
	
	/**
	 * Create the barycentric packing for a new tiling, namely
	 * that obtained from the current tiling by breaking each
	 * n-gon tile T into n pentagons with twist pattern. Use the 
	 * original vertices of T along with two vertices for each
	 * of its edges. "Left twist" means first counterclockwise 
	 * new vert on an edge is the fake corner, barycenter attaches 
	 * to the second. "Right twist" is opposite
	 * @param p PackData
	 * @param righttwist boolean: true, then twist right instead of left
	 * @return new PackData
	 */
	public PackData twistize(PackData p,boolean righttwist) {

		// is there tile data?
		if (p.tileData==null || p.tileData.tileCount==0) {
			return null;
		}

		// count the number of tiles
		int ecount=1;
		for (int t=1;t<=p.tileData.tileCount;t++) 
			ecount +=p.tileData.myTiles[t].vertCount;

		// create a packing with new edge vertices
		PackData triPD=trilize(p.tileData); //DebugHelp.debugPackWrite(triPD,"twistDebug.p");
		if (triPD==null) {
			errorMsg("failed to trilize");
			return null;
		}
		Tile []newTiles=new Tile[ecount];
		
		// create the new tiles
		int tcount=0;
		for (int t=1;t<=p.tileData.tileCount;t++) {
			Tile tile=p.tileData.myTiles[t];
			for (int j=0;j<tile.vertCount;j++) {
				Tile nt=newTiles[++tcount]=new Tile(p.tileData,5);
				nt.tileIndex=tcount;
				int b=tile.baryVert;
				int v=tile.vert[j];
				int num=triPD.kData[b].num;
				int indx_bv=triPD.nghb(b,v);
				if (righttwist) {
					int w=triPD.kData[b].flower[(indx_bv-2+num)%num];
					int u=triPD.kData[b].flower[(indx_bv-1)%num];
					int s=triPD.kData[b].flower[(indx_bv+1)%num];
					nt.vert[0]=b;
					nt.vert[1]=w;
					nt.vert[2]=u;
					nt.vert[3]=v;
					nt.vert[4]=s;
				}
				else {
					int w=triPD.kData[b].flower[(indx_bv-1+num)%num];
					int u=triPD.kData[b].flower[(indx_bv+1)%num];
					int s=triPD.kData[b].flower[(indx_bv+2)%num];
					nt.vert[0]=b;
					nt.vert[1]=w;
					nt.vert[2]=v;
					nt.vert[3]=u;
					nt.vert[4]=s;
				}
			}
		}
		triPD.tileData.tileCount=tcount;
		triPD.tileData.myTiles=newTiles;

		// create packing from new tiling.
		triPD = TileData.tiles2canonical(triPD.tileData);
		return triPD;
	}
	
	/**
	 * Create the barycentric packing for a new tiling, namely
	 * that obtained from the current tiling by breaking each
	 * n-gon tile into n 5-gons in the corners and a central n-gon
	 * @param td TileData
	 * @return new PackData
	 */
	public PackData pentatize(TileData td) {

		// is there tile data?
		if (td==null || td.tileCount<=0) {
			return null;
		}

		// estimate number of tiles, new nodecount
		int tcount=0;
		for (int t=1;t<=td.tileCount;t++) 
			tcount +=td.myTiles[t].vertCount;
		tcount+=td.tileCount+1;
		
		// create a packing with edge barycenters
		// try 'tiles2BullBary'
		PackData newPD=TileData.tiles2FullBary(td);
//		PackData newPD=TileData.tiles2canonical(td);
		
		// create new tile space
		Tile []newTiles=new Tile[tcount];
		
		// create the new tile data; new verts are old+nodeCount
		tcount=0;
		int nextv=newPD.nodeCount; // new vert indices
		for (int t=1;t<=newPD.tileData.tileCount;t++) {
			Tile tile=newPD.tileData.myTiles[t];
			
			// new central tile; 
			Tile nct=newTiles[++tcount]=new Tile(newPD.tileData,tile.vertCount);
			nct.tileIndex=tcount;
			for (int j=0;j<tile.vertCount;j++)
				nct.vert[j]=++nextv;
			// new pentagons in the corners
			for (int j=0;j<tile.vertCount;j++) {
				Tile nt=newTiles[++tcount]=new Tile(newPD.tileData,5);
				nt.tileIndex=tcount;
				int b=tile.baryVert;
				int v=tile.vert[j];
				int num=newPD.kData[b].num;
				int indx_bv=newPD.nghb(b,v);
				int u=newPD.kData[b].flower[(indx_bv-1+num)%num];
				int w=newPD.kData[b].flower[(indx_bv+1)%num];
				nt.vert[0]=v;
				nt.vert[1]=w;
				nt.vert[2]=nct.vert[(j+1)%nct.vertCount];
				nt.vert[3]=nct.vert[j];
				nt.vert[4]=u;
			}
		}
		newPD.tileData.tileCount=tcount;
		newPD.tileData.myTiles=newTiles;
				
		// create packing from new tiling.
		// try 'tiles2FullBary'
		return (TileData.tiles2FullBary(newPD.tileData));
//		return (TileData.tiles2canonical(newPD.tileData));
	}

	/**
	 * Create a packing from 'tileData' obtained by barycentrically
	 * subdividing the original tiles.
	 * @param td TileData
	 * @return PackData, null on error
	 */
	public PackData baryize(TileData td) {

		// is there tile data?
		if (td==null || td.tileCount<=0) {
			return null;
		}

		// estimate number of tiles
		int ecount=1;
		for (int t=1;t<=td.tileCount;t++) 
			ecount +=2*td.myTiles[t].vertCount;
		
		PackData newPD=TileData.tiles2canonical(td);
		
		// point to new tiles
		Tile []newTiles=new Tile[ecount];
		
		// create the new triangles in newPD
		int tcount=0;
		for (int t=1;t<=td.tileCount;t++) {
			Tile tile=td.myTiles[t];
			int b=tile.baryVert;
			int num=newPD.kData[b].num;
			for (int j=0;j<tile.vertCount;j++) {
				int v=tile.vert[j];
				int indx_bv=newPD.nghb(b,v);
				int w=newPD.kData[b].flower[(indx_bv-1+num)%num];
				int u=newPD.kData[b].flower[(indx_bv+1)%num];
				
				// one triangle
				Tile nt=newTiles[++tcount]=new Tile(newPD.tileData,3);
				nt.tileIndex=tcount;
				nt.vert[0]=b;
				nt.vert[1]=w;
				nt.vert[2]=v;
				
				// another triangle
				nt=newTiles[++tcount]=new Tile(newPD.tileData,3);
				nt.tileIndex=tcount;
				nt.vert[0]=b;
				nt.vert[1]=v;
				nt.vert[2]=u;
			}
		}
		newPD.tileData.tileCount=tcount;
		newPD.tileData.myTiles=newTiles;
		
		// create packing from new tiling.
		newPD = TileData.tiles2canonical(newPD.tileData);
		return newPD;
	}

	/**
	 * The 'delta' subdivision divides an n tile into
	 * a central n tile and 2n triangles.
	 * @param td TileData
	 * @return PackData
	 */
	public PackData deltize(TileData td) {

		// is there tile data?
		if (td==null || td.tileCount<=0) {
			return null;
		}

		// count
		int tcount=1;
		for (int t=1;t<=td.tileCount;t++)
			tcount += 2*td.myTiles[t].vertCount;
		tcount += td.tileCount;
		
		// create packing to use
		PackData newPD=TileData.tiles2packing(td);
		
		// point to new tiles
		Tile []newTiles=new Tile[tcount];
		
		// create the new tile data;
		tcount=0;
		int nextv=newPD.nodeCount; // new vert indices
		for (int t=1;t<=newPD.tileData.tileCount;t++) {
			Tile tile=newPD.tileData.myTiles[t];
			int v=tile.baryVert;
			int num=newPD.kData[v].num;
			
			// new central tile; 
			Tile nct=newTiles[++tcount]=new Tile(newPD.tileData,tile.vertCount);
			nct.tileIndex=tcount;
			int thestart=nextv+1;
			for (int j=0;j<num;j++)
				nct.vert[j]=++nextv;
			
			// 2 new triangles for each vert/edge
			for (int j=0;j<num;j++) {
				int a=thestart+j;
				int b=newPD.kData[v].flower[j];
				int c=newPD.kData[v].flower[j+1];
				int d=thestart+(j+1)%num;
				
				// new triangle <a,b,c>
				Tile nt=newTiles[++tcount]=new Tile(newPD.tileData,3);
				nt.tileIndex=tcount;
				nt.vert[0]=a;
				nt.vert[1]=b;
				nt.vert[2]=c;
				
				// new triangle <a,c,d>
				nt=newTiles[++tcount]=new Tile(newPD.tileData,3);
				nt.tileIndex=tcount;
				nt.vert[0]=a;
				nt.vert[1]=c;
				nt.vert[2]=d;
			}
		}
		newPD.tileData.tileCount=tcount;
		newPD.tileData.myTiles=newTiles;
		
		// create packing from new tiling.
		newPD = TileData.tiles2canonical(newPD.tileData);
		return newPD;
	}

	/**
	 * The 'star' of a tiling breaks each tile with n edges
	 * into n triangle tiles with new edges to the vertices. 
	 * @param td TileData
	 * @return PackData
	 */
	public PackData starize(TileData td) {

		// is there tile data?
		if (td==null || td.tileCount<=0) {
			return null;
		}
		
		// count
		int count=0;
		for (int j=1;j<=td.tileCount;j++)
			count +=td.myTiles[j].vertCount;
		Tile []newTiles=new Tile[count+1];
		
		// create the new myTiles
		int tcount=0;
		for (int t=1;t<=td.tileCount;t++) {
			Tile tile=td.myTiles[t];
			for (int j=0;j<tile.vertCount;j++) {
				// new tile for edge vert[j],vert[j+1]
				Tile nct=newTiles[++tcount]=new Tile(td,3);
				nct.tileIndex=tcount;
				nct.vert[0]=tile.baryVert; 
				nct.vert[1]=tile.vert[j];
				nct.vert[2]=tile.vert[(j+1)%tile.vertCount];
			}
		}
		
		TileData newTD=new TileData(tcount,td.builtMode);
		newTD.myTiles=newTiles;
		
		// create packing from new tiling.
		return (TileData.tiles2canonical(newTD));
	}

	/**
	 * The 'hex' decomposition of a tiling adds a vertex to each
	 * edge and connects the next edge. So an n-tile ends up as
	 * a central n-tile and n triangle tiles, generalizing 'hex_refine'.
	 * @param td TileData
	 * @return PackData
	 */
	public PackData hexize(TileData td) {

		// is there tile data?
		if (td==null || td.tileCount<=0) {
			return null;
		}

		// estimate number of tiles
		int ecount=td.tileCount+1;
		for (int t=1;t<=td.tileCount;t++) 
			ecount +=td.myTiles[t].vertCount;
		
		PackData newPD=TileData.tiles2canonical(td);

		Tile []newTiles=new Tile[ecount];
		
		// create the new tile data in newTiles
		int tcount=0;
		for (int t=1;t<=td.tileCount;t++) {
			Tile tile=td.myTiles[t];
			int b=tile.baryVert;
			int v=tile.vert[0];

			// central tile (corners are edge mid points)
			newTiles[++tcount]=new Tile(newPD.tileData,tile.vertCount);
			newTiles[tcount].tileIndex=tcount;
			int idx=newPD.nghb(b,v);
			int num=newPD.kData[b].num;
			for (int j=0;j<tile.vertCount;j++)
				newTiles[tcount].vert[j]=newPD.kData[b].flower[(1+2*j)%num];
			
			// new triangles in the corners
			for (int j=0;j<tile.vertCount;j++) {
				v=tile.vert[j];
				idx=newPD.nghb(b, v);
				Tile nt=newTiles[++tcount]=new Tile(newPD.tileData,3);
				nt.tileIndex=tcount;
				int w=newPD.kData[b].flower[(idx-1+num)%num];
				int u=newPD.kData[b].flower[(idx+1)%num];
				nt.vert[0]=v;
				nt.vert[1]=u;
				nt.vert[2]=w;
			}
		}
		newPD.tileData.tileCount=tcount;
		newPD.tileData.myTiles=newTiles;
		
		// create packing from new tiling.
		newPD = TileData.tiles2canonical(newPD.tileData);
		return newPD;
	}

	/**
	 * Using data from the parent packing, compute the interior
	 * angle sum at vertex of given index in tile's augmented vertices.
	 * @param tile Tile
	 * @param av int, index of vertex
	 * @return double angle/PI, <=0 on error
	 */
	public double getAugAngle(Tile tile,int av) {
		if (tile==null || tile.augVert==null || av<0 || av>=tile.augVertCount)
			return -1;
		int v=tile.augVert[av];
		// uv,v,dv in ccw order at vert v
		int cwv=tile.augVert[(av-1+tile.augVertCount)%tile.augVertCount];
		int ccwv=tile.augVert[(av+1)%tile.augVertCount];
		
		int num=packData.kData[v].num;
		double vrad=packData.getRadius(v);
		double rad1=packData.getRadius(ccwv);
		double rad2=rad1;
		int ccwv_indx=packData.nghb(v, ccwv);
		int indxdiff=(packData.nghb(v, cwv)-ccwv_indx+num)%num;
		int hes=packData.hes;
		double angsum=0.0;
		for (int k=1;k<=indxdiff;k++) {
			rad1=rad2;
			rad2=packData.getRadius(packData.kData[v].flower[(ccwv_indx+k)%num]);
			UtilPacket uP=new UtilPacket();
			if (hes<0) { // hyp
				HyperbolicMath.h_cos_s_overlap(vrad,rad1,rad2,1.0,1.0,1.0,uP);
				angsum+=Math.acos(uP.value);
			}
			else if (hes>0) { // sph
				angsum+=Math.acos(SphericalMath.s_comp_cos(vrad,rad1,rad2));
				
			}
			else { // eucl
				EuclMath.e_cos_overlap(vrad,rad1,rad2,uP);
				angsum+=Math.acos(uP.value);
			}
		}
		return angsum/Math.PI;
	}
	
	/**
	 * Get the canonicalPack if it exists
	 * @return
	 */
	public PackData getCanonicalPack() {
		return canonicalPack;
	}
	
	/**
	 * For drawing euclidean tiles; centers set in 'store_eucl', recurse
	 * while there are subtiles.
	 * @param 
	 */
	public int recurseDrawTile(Tile tile,DispFlags dflags) {
		int count=0;
		
		// first, draw yourself, then recursively draw any children
		int n=tile.vertCount;
		double []stdC=new double[2*n];
		for (int j=0;j<n;j++) {
			Complex z=packData.getCenter(tile.vert[j]);
			stdC[2*j]=z.x;
			stdC[2*j+1]=z.y;
		}
		count++;
		
		packData.cpScreen.drawClosedPoly(n,stdC,dflags);
		if (tile.myTileData!=null) {
			for (int t=1;t<=tile.myTileData.tileCount;t++) {
				Tile mytile=tile.myTileData.myTiles[t];
				count +=recurseDrawTile(mytile,dflags);
			}
		}
		return count;
	}

	/**
	 * recursively set eucl tile vert locations for subdivision rule to given depth; 
	 * tile rules must have optional position data from *.r rules file. The new
	 * centers are in 'p' and vertices 'mark' is set to depth
	 * 
	 * @param p PackData
	 * @param sRules SubdivisionRules, (with optional position data)
	 * @param toptile Tile
	 * @param base Complex[2], base of this tile
	 * @param depth int, recursive depth
	 * @return int
	 */
	public int setEuclRecurs(PackData p,SubdivisionRules sRules,Tile toptile,Complex []base,int depth) {
		TileRule topRule=sRules.tileRules.get(toptile.tileType-4);

		// for transformations
		Complex origin=base[0];
		Complex basedir=base[1].minus(base[0]);
		
		// first, locate your own vertices (just vertices, not augmented vertices)
		for (int j=0;j<topRule.stdCorners.length;j++) {
			p.setCenter(toptile.vert[j],new Complex(topRule.stdCorners[j].times(basedir).add(origin)));
			if (p.kData[toptile.vert[j]].mark<0)
				p.kData[toptile.vert[j]].mark=depth;
		}

		int count=1;

		// recurse through children
		try {
		if (depth > 0) {
			for (int n = 1; n <= topRule.childCount; n++) {
				Complex []subtileBase=new Complex[2];
				subtileBase[0] = new Complex(topRule.tileBase[n][0].times(basedir).add(origin));
				subtileBase[1] = new Complex(topRule.tileBase[n][1].times(basedir).add(origin));
				int rslt = setEuclRecurs(p,sRules, toptile.myTileData.myTiles[n], subtileBase, depth - 1);
				if (rslt <= 0)
					return 0;
				count += rslt;
			}
		}
		} catch (Exception ex) {
			throw new CombException("problem recursing through child tiles");
		}
		
		return count;
	}
     
	/**
	 * If 'tData' has 'subRules' and appropriate 'tileType's, then 
	 * build the cannonical circle packing for 'tData' recursively 
	 * to the given 'depth', attaching 'tData' as its 'tileData'. 
	 * Note that depth=0 is just the cannonical tiling for 'tData'.
	 * 
	 * This builds a new PackData and updates and attaches 'tData' 
	 * based on 'tData's initial TileData structure. 'tData' must 
	 * have the tiles, with consistent 'tile.vert's, and must have 
	 * 'tileFlower's. (Note, eg, that for subdivision rules, may 
	 * have to run 'SubdivsionRules.getRulesTD' to set consistent
	 * vertex indices.) If the tiles have non-null 'myTileData', 
	 * then they themselves represent tilings (as when we build 
	 * from subdivision rules).
	 *
	 * Therefore, this is a recursive construction: At a given level, 
	 * a tiling is created one tile at a time with its associated packing;
	 * this is pasted onto a growing global packing (for this level) and
	 * the TileData tiles are updated, with 'augmented' vertices from 
	 * the local packing; as that is absorbed into the growing global 
	 * packing, we update 'vert' and 'augVert' indices to the parent 
	 * packing and then discard the local packing to save space (but the 
	 * local 'TileData' is now part of the parent's TileData). 
	 *
	 * We do not build a global 'TileData' that has tiles down to
	 * the finest level. Instead, each 'Tile' at level j>0 contains 
	 * 'TileData' for j-1 level tiles.
	 * 
	 * TODO: build a "collapse" method that builds the tiling down to
	 * the finest level for purposes of saving it. 
	 * 
	 * When 'depth' is 0, return canonical packing for 'tData' with
	 * 'tData' as it 'tileData'. This happens, e.g., at the bottom of 
	 * every recursion cycle.
	 * 
	 * We save/use prepared packings as we go in 'depthPD'. When this is
	 * not null, then if depthPD(tt)(d) exists, it holds PackData for tile
	 * type tt at subdivision depth d (in mode=3 form).
	 *  
	 * @param tData TileData
	 * @param depth int, (depth = 0 for no subdivision)
	 * @param mode int: 1=simple, 2=edge barycenters, 3=full barycentric (default)
	 * @param depthPD Vector<Vector<PackData>: pre-stored packdata
	 * @return PackData (holding also its 'tileData') or null on error
	 */
	public static PackData build2Depth(TileData tData,int depth,int mode,
			Vector<TileData> topTD,Vector<Vector<PackData>> depthPD) {
		
		// can use saved 'TileData' and 'PackData' only if mode == 3
//		if (mode!=3) {
//			topTD=null;
//			depthPD=null;
//		}
		
		if (buildDeBug) {
			int pTt=-1;
			if (tData.parentTile!=null)
				pTt=tData.parentTile.tileType;
			System.out.println("enter 'build2Depth': tileCount = "+
				tData.tileCount+", depth ="+depth+", parent tile type = "+pTt);
		}
		
		if (depth>0 && tData.subRules==null) // buildDeBug=true;
			throw new DataException("no subdivision rules are specified");

		if (depth>targetDepth)
			targetDepth=depth;
		
		// ************************ only 1 tile?
		if (tData.tileCount==1) {
			Tile tile=tData.myTiles[1];
			int tt=tData.myTiles[1].tileType;
			
			// type not set? choose first one that has right size
			if (tt==0) {
				tt=tData.subRules.getPossibleType(tData.myTiles[1].vertCount);
				if (tt<0) {
					CirclePack.cpb.myErrorMsg("No tile type with "+tData.myTiles[1].vertCount+" edges");
					return null;
				}
			}
			if (buildDeBug) {
				System.out.println("  one tile, type "+tile.tileType);
			}
			PackData tmpPD=null;
			boolean needsave=false;
			
			// depth 0?
			if (depth==0) {
				
				// this packing should have been created when the rules were loaded
				if (depthPD!=null) {
					tmpPD=copyDepthPacking(depthPD,tt,depth);
				}
				
				// didn't have one to copy? build the packing
				if (tmpPD==null) {
					tmpPD=tData.myTiles[1].singleCanonical(mode);
					needsave=true;
				}
				
				// transfer new data to original tile
				tile.augVertCount=tmpPD.tileData.myTiles[1].augVertCount;
				tile.augVert=new int[tile.augVertCount];
				for (int si=0;si<tile.augVertCount;si++)
					tile.augVert[si]=tmpPD.tileData.myTiles[1].augVert[si];
				tile.vert=new int[tile.vertCount];
				for (int si=0;si<tile.vertCount;si++)
					tile.vert[si]=tmpPD.tileData.myTiles[1].vert[si];
				tile.baryVert=tmpPD.tileData.myTiles[1].baryVert;
				
				// no neighbors, so all zeros
				tile.tileFlower=new int[tile.vertCount][2];
				for (int i=0;i<tile.vertCount;i++)
					tile.tileFlower[i][0]=0;
				
				// Do we need a copy of the one just built (should not at depth=0)
				Vector<PackData> vpd=null;
				if (needsave && tt>=4 && depthPD!=null && 
						(vpd=depthPD.get(tt))!=null && (vpd.size()<=depth || vpd.get(depth)==null)) {
					if (vpd.size()<=depth)
						vpd.setSize(depth+1);
					PackData savePD=tmpPD.copyPackTo();
					vpd.setElementAt(savePD,depth);
					needsave=false;
//					CirclePack.cpb.msg("added depth "+depth+", type "+tt);
				}
				
				tile.TDparent=tData;
				tmpPD.tileData=tData;
				return tmpPD;
			}
			
			if (depth==(targetDepth-1)) // show that we're nearing target depth 
				System.out.println("at depth "+depth);
			
			// otherwise, we must get stored subdivision 'TileData'
			TileData tmpTD=topTD.get(tt).copyMyTileData();
			tmpTD.subRules=tData.subRules;
			
			// now see if we've done this packing, else recurse to get the associated packing
			if (depthPD!=null && depthPD.get(tt).size()>depth) {
				tmpPD=copyDepthPacking(depthPD,tt,depth);
				needsave=false;
			}
			
			// didn't have one to copy? build the packing
			if (tmpPD==null) {
				tmpPD=build2Depth(tmpTD,depth-1,mode,topTD,depthPD);
				needsave=true;
			}
			
			// fix up our one tile, create augmented vertices
			tData.myTiles[1].myTileData=tmpPD.tileData;
//			for (int j=1;j<=tData.myTiles[1].myTileData.tileCount;j++)
//				tData.myTiles[1].myTileData.myTiles[j].TDparent=tData.myTiles[1].myTileData;
			tData.myTiles[1].myTileData.parentTile=tData.myTiles[1];
			tData.createAugBorder(1);
			
			// TODO: for single tile, would like top level vertices to be
			//       set to 1,2,...,n, but will have to recursively change in
			//       all deeper vert and augVert lists. 
			
			// Do we need a copy of the one just built
			Vector<PackData> vpd=null;
			if (needsave && depthPD!=null &&
					(vpd=depthPD.get(tt))!=null && (vpd.size()<=depth || vpd.get(depth)==null)) {
				if (vpd.size()<=depth)
					vpd.setSize(depth+1);
				PackData savePD=tmpPD.copyPackTo();
				vpd.setElementAt(savePD,depth);
				needsave=false;
//				String fdbk="added depth "+depth+", type "+tt;
//				CirclePack.cpb.msg(fdbk);
//				System.out.println(fdbk);
			}
			
			// return new packing with original 'tData' attached
			tmpPD.tileData=tData;
			return tmpPD;
		}
		
		// **************************** else, multiple tiles: 
		// maintain 2 lists; indices of current tiles, new ones that are touched
		Vector<Integer> curr=null; 
		Vector<Integer> next= new Vector<Integer>();

		if (depth==(targetDepth-1)) // show that we're nearing target depth 
			System.out.println("at depth "+depth);
		
		// 'tileFlower' entries not yet pasted are set negative
		for (int t=1;t<=tData.tileCount;t++) {
			Tile tile=tData.myTiles[t];
			for (int j=0;j<tile.vertCount;j++) // set tileFlower entries negative
				tile.tileFlower[j][0]=-Math.abs(tile.tileFlower[j][0]);
		}
		
		// track tiles whose packings are created, and those with pasting done
		int []tilepack=new int[tData.tileCount+1];
		int []tiledone=new int[tData.tileCount+1];
		
		// 'p' is parent packing we are building, 'tilePack' is current tile packing
		PackData p=null; 
		PackData tilePack=null;
		
		// start 'p' with first tile
		Tile tile=tData.myTiles[1]; // tile.debugPrint();
		boolean needsave=false;
		if (depth==0) {
			int tt=tile.tileType;
			
			// type not set? choose first one that has right size
			if (tt==0) {
				tt=tData.subRules.getPossibleType(tData.myTiles[1].vertCount);
				if (tt<0) {
					CirclePack.cpb.myErrorMsg("No tile type with "+tData.myTiles[1].vertCount+" edges");
					return null;
				}
			}
			
			if (depthPD!=null && depthPD.get(tt).size()>depth) {
				p=copyDepthPacking(depthPD,tt,depth);
			}
			
			// didn't have one to copy? build the packing
			if (p==null) {
				p=tile.singleCanonical(mode);
				needsave=true;
			}
			
			// transfer new data to original tile
			tile.augVertCount=p.tileData.myTiles[1].augVertCount;
			tile.augVert=new int[p.tileData.myTiles[1].augVertCount];
			for (int si=0;si<tile.augVertCount;si++)
				tile.augVert[si]=p.tileData.myTiles[1].augVert[si];
			tile.vert=new int[p.tileData.myTiles[1].vertCount];
			for (int si=0;si<tile.vertCount;si++)
				tile.vert[si]=p.tileData.myTiles[1].vert[si];
			tile.baryVert=p.tileData.myTiles[1].baryVert;
			
			// Do we need a copy of the one just built
			Vector<PackData> vpd=null;
			if (depthPD!=null && needsave &&
					(vpd=depthPD.get(tt))!=null && (vpd.size()<=depth || vpd.get(depth)==null)) {
				if (vpd.size()<=depth)
					vpd.setSize(depth+1);
				PackData savePD=p.copyPackTo();
				vpd.setElementAt(savePD,depth);
//				String fdbk="added depth "+depth+", type "+tt;
//				CirclePack.cpb.msg(fdbk);
//				System.out.println(fdbk);
				needsave=false;
			}
			
			tile.TDparent=tData;
			// TODO: must we update 'tileFlower's ?
		}
		else { // otherwise, we must create the subdivision 'TileData'
			int tt=tData.myTiles[1].tileType;
			
			// type not set? error
			if (tt==0) 
				throw new CombException("should have tile type at this point");

			// otherwise, we must get stored subdivision 'TileData'
			TileData tmpTD=topTD.get(tt).copyMyTileData();
			tmpTD.subRules=tData.subRules;
			
			// now see if we've done this packing, else recurse to get the associated packing
			if (depthPD!=null && depthPD.get(tt).size()>depth) {
				p=copyDepthPacking(depthPD,tt,depth);
			}
			
			// didn't have one to copy? build the packing
			if (p==null) {
				p=build2Depth(tmpTD,depth-1,mode,topTD,depthPD);
				needsave=true;
			}

			// fix this tile, create augmented vertices
			tData.myTiles[1].myTileData=p.tileData;
			tData.myTiles[1].myTileData.parentTile=tData.myTiles[1];
			for (int j=1;j<=tData.myTiles[1].myTileData.tileCount;j++)
				tData.myTiles[1].myTileData.myTiles[j].TDparent=tData.myTiles[1].myTileData;
			tData.createAugBorder(1); // tData.myTiles[1].debugPrint();
			
			// Do we need a copy of the one just built
			Vector<PackData> vpd=null;
			if (depthPD!=null && needsave &&
					(vpd=depthPD.get(tt))!=null && (vpd.size()<=depth || vpd.get(depth)==null)) {
				if (vpd.size()<=depth)
					vpd.setSize(depth+1);
				PackData savePD=p.copyPackTo();
				vpd.setElementAt(savePD,depth);
//				String fdbk="added depth "+depth+", type "+tt;
//				CirclePack.cpb.msg(fdbk);
//				System.out.println(fdbk);
				needsave=false;
			}
		}

		next.add(1); // put in list for later processing
		tilepack[1]=1;
		
		// now cycle between 'curr' and 'next'		
		int safety=100*tData.tileCount;
		while (next.size()>0) {
			curr=next;
			next=new Vector<Integer>();
			while (curr.size()>0 && safety>0) {
				safety--;
				int t=curr.remove(0); // get the next tile
				tile=tData.myTiles[t];
				
				// entries go into 'next' (and later into 'curr') as their 
				//    packings are generated and then pasted to growing pack 'p'.
				
				// go around tileFlower to paste (or create and paste) tiles on;
				//    self-pastings of edges may occur. Identification of vertices
				//    is not needed, as they will eventuate when further pasting
				//    is done.
				if (tiledone[t]!=0) 
					break;

				// go through the as yet unpasted edges
				for (int ti=0;ti<tile.vertCount;ti++) {
					if (tile.tileFlower[ti][0]<0) {
						int nghbJ=Math.abs(tile.tileFlower[ti][0]);
						Tile nghbTile=tData.myTiles[nghbJ]; // nghbTile.debugPrint();
						int tt=tData.myTiles[nghbJ].tileType;
						
						// type not set? error
						if (tt==0) 
							throw new CombException("should have tile type at this point");
						
						boolean isnew=false;
						
						// do we need to create?
						if (tilepack[nghbJ]==0) {
							tilePack=null;
							isnew=true;

							if (depth==0) { 
								if (depthPD!=null && depthPD.get(tt).size()>depth) {
									tilePack=copyDepthPacking(depthPD,tt,depth);
								}
								
								// didn't have one to copy? build the packing
								if (tilePack==null) {
									tilePack=nghbTile.singleCanonical(mode);
									needsave=true;
								}
								
								// transfer new data to original tile
								nghbTile.augVertCount=tilePack.tileData.myTiles[1].augVertCount;
								nghbTile.augVert=new int[tilePack.tileData.myTiles[1].augVertCount];
								for (int si=0;si<nghbTile.augVertCount;si++)
									nghbTile.augVert[si]=tilePack.tileData.myTiles[1].augVert[si];
								nghbTile.vert=new int[tilePack.tileData.myTiles[1].vertCount];
								for (int si=0;si<nghbTile.vertCount;si++)
									nghbTile.vert[si]=tilePack.tileData.myTiles[1].vert[si];
								nghbTile.baryVert=tilePack.tileData.myTiles[1].baryVert;
								
								// Do we need a copy of the one just built
								Vector<PackData> vpd=null;
								if (depthPD!=null && needsave &&
										(vpd=depthPD.get(tt))!=null && (vpd.size()<=depth || vpd.get(depth)==null)) {
									if (vpd.size()<=depth)
										vpd.setSize(depth+1);
									PackData savePD=tilePack.copyPackTo();
									vpd.setElementAt(savePD,depth);
//									String fdbk="added depth "+depth+", type "+tt;
//									CirclePack.cpb.msg(fdbk);
//									System.out.println(fdbk);
									needsave=false;
								}
								
								nghbTile.TDparent=tData;
							}
							else {
								TileData tmpTD=topTD.get(tt).copyMyTileData();
								tmpTD.subRules=tData.subRules;
								
								if (depthPD!=null && depthPD.get(tt).size()>depth) {
									tilePack=copyDepthPacking(depthPD,tt,depth);
								}
								
								// didn't have one to copy? build the packing
								if (tilePack==null) {
									tilePack=build2Depth(tmpTD,depth-1,mode,topTD,depthPD);
									needsave=true;
								}
								
								// update this tile, create its augmented vertices
								nghbTile.myTileData=tilePack.tileData;
								nghbTile.myTileData.parentTile=nghbTile;
								for (int j=1;j<=nghbTile.myTileData.tileCount;j++)
									nghbTile.myTileData.myTiles[j].TDparent=nghbTile.myTileData;
								tData.createAugBorder(nghbJ);
								
								// Do we need a copy of the one just built
								Vector<PackData> vpd=null;
								if (depthPD!=null && needsave &&
										(vpd=depthPD.get(tt))!=null && (vpd.size()<=depth || vpd.get(depth)==null)) {
									if (vpd.size()<=depth)
										vpd.setSize(depth+1);
									PackData savePD=tilePack.copyPackTo();
									vpd.setElementAt(savePD,depth);
//									String fdbk="added depth "+depth+", type "+tt;
//									CirclePack.cpb.msg(fdbk);
//									System.out.println(fdbk);
									needsave=false;
								}
								
								tilePack.tileData=null;  
							}
							
							tilepack[nghbJ]=1;
							next.add(Integer.valueOf(nghbJ));
						}
						else // self pasting 
							tilePack=p;
						
						// find how to paste 'nghbTile' to 'tile' (may be self-pasting)
						int nti=tile.tileFlower[ti][1];
						if (tile.tileFlower[ti][0]>0 && tile.tileFlower[ti][0]!=nghbJ)
							throw new CombException("not the nghb tile expected");
						
						// get the list of vertices defining the edges
						NodeLink tedge=tile.findAugEdge(ti);
						NodeLink nghbedge=nghbTile.findAugEdge(nti);
						int n=tedge.size()-1;
						if ((nghbedge.size()-1)!=n)
							throw new CombException("edge sizes don't match");

						int v=tedge.get(n);
						int w=nghbedge.get(0);
						
						int adrslt=p.adjoin(tilePack,v,w,n); // DebugHelp.debugPackWrite(p,"tilestage");
						if (adrslt!=1) {
							return null;
						}
						p.complex_count(true);
						
						// reset info
						tile.tileFlower[ti][0]=Math.abs(tile.tileFlower[ti][0]);
						nghbTile.tileFlower[nti][0]=tile.tileIndex;
						
						// recursively update vertices
						if (isnew) { // reset just for this new tile
							tData.myTiles[nghbJ].updateMyVerts(p.vertexMap);
						}
						else { // self pasting of p; adjust all attached tiles
							for (int j=1;j<=tData.tileCount;j++) {
								if (tilepack[j]==1)
									tData.myTiles[j].updateMyVerts(p.vertexMap);
							}
						}

					}
				} // done pasting tile's edges
				tiledone[tile.tileIndex]=1;
			} // end of while on 'curr'
		} // end of while on 'next'
		
		
		// attach updated 'tData'
		p.tileData=tData;
		return p;
	}
	
	/**
	 * Given 'tData' must represent a tiling tree structure, meaning that
	 * its 'myTiles' are pointers to tilings in a hierarchy. This command 
	 * consolidates the tiling tree into a single tiling by tiles at a 
	 * given 'depth' (the original 'tData' being depth 0).
	 * 
	 * The consolidated tiles remain as pointers to the tiles at the 
	 * designated depth.
	 * @param tData TileData, 
	 * @param depth int, set large to get max depth
	 * @return TileData
	 */
	public static TileData consolidateTiling(TileData tData,int depth) {
		
		// recursively accumulate a vector of all leaf tiles 
		Vector<Tile> tVec=new Vector<Tile>();
		for (int t=1;t<=tData.tileCount;t++) {
			Vector<Tile> tmpV=accumTiles(tData.myTiles[t],depth);
			for (int k=0;k<tmpV.size();k++) {
				tVec.add(tmpV.get(k));
			}
		}
		
		// now create the new TileData structure and add all the tiles
		TileData outData=new TileData(tVec.size(),tData.builtMode);
		Iterator<Tile> tV=tVec.iterator();
		int tick=0;
		while (tV.hasNext()) {
			outData.myTiles[++tick]=tV.next();
			outData.myTiles[tick].tileIndex=tick;
		}
		return outData;
	}

	/**
	 * Return vector of tiles at 'depth' obtained recursively starting
	 * with given 'tile'.
	 * @param tile Tile 
	 * @param int depth; -1 is full depth
	 * @return Vector<Tile>, may be empty
	 */
	public static Vector<Tile> accumTiles(Tile tile,int depth) {
		Vector<Tile> tVec=new Vector<Tile>();
		
		// in some cases return this tile itself
		if (depth==0 || tile.myTileData==null || tile.myTileData.tileCount<1) {
			tVec.add(tile);
			return tVec;
		}
		
		// else go recursively into 'myTileData'
		for (int j=1;j<=tile.myTileData.tileCount;j++) {
			Vector<Tile> tmpV=new Vector<Tile>();
			tmpV=accumTiles(tile.myTileData.myTiles[j],depth-1);
			for (int k=0;k<tmpV.size();k++)
				tVec.add(tmpV.get(k));
		}
		return tVec;
	}
	
	/** 
	 * Return vector of indices of tiles in packData.tileData which together
	 * with all ancestors in tiling hierarchy are marked (or all are unmarked). 
	 * If no hierarchy, just check for tiles. Else, first determine depth of
	 * packData.tileData, then serch to that depth using 'accumMarked'.
	 * @param marked boolean; true, want marked tiles; false, want unmarked
	 * @return Vector<Integer>, may be empty
	 */
	public Vector<Integer> listMarkedTiles(boolean marked) {
		Vector<Integer> vecans=new Vector<Integer>(0);
		if (packData==null || packData.tileData==null || packData.tileData.tileCount==0)
			return vecans;
		
		// if no hierarchy, just look at current tiles
		if (canonicalPack==null || canonicalPack.tileData==null || 
				canonicalPack.tileData.gradedTileData==null) {
			for (int t=1;t<=packData.tileData.tileCount;t++) {
				Tile tile=packData.tileData.myTiles[t];
				if ((tile.mark!=0 && marked) ||	(tile.mark==0 && !marked))
					vecans.add(tile.tileIndex);
			}
			return vecans;
		}
		
		int depth=whatDepth(packData);
		if (depth<0)
			return vecans;
		
		// need recursive call through hierarchy; start at top, coarse level
		Vector<TileData> gTD=canonicalPack.tileData.gradedTileData;
		TileData coarseTD=gTD.get(0);
		Vector<Tile> tmpVec=new Vector<Tile>();
		for (int t=1;t<=coarseTD.tileCount;t++) {
			Tile tile=coarseTD.myTiles[t];
			Vector<Tile> vec=accumMarked(tile,depth,marked);
			for (int k=0;k<vec.size();k++)
				tmpVec.add(vec.get(k));
		}
			
		Iterator<Tile> tv=tmpVec.iterator();
		while (tv.hasNext()) {
			Tile tile=tv.next();
			vecans.add(tile.tileIndex);
		}
		
		return vecans;
	}
	
	/**
	 * Return vector of tiles at 'depth' which are marked and whose parent 
	 * tiles in tiling hierarchy are all marked as well. Recursive.
	 * @param tile Tile
	 * @param depth int
	 * @param marked boolean; true, want marked; false, want unmarked
	 * @return Vector<Tile>, may be empty
	 */
	public static Vector<Tile> accumMarked(Tile tile,int depth,boolean marked) {
		Vector<Tile> tVec=new Vector<Tile>();
		
		// in some cases return this tile itself
		if (depth==0 || tile.myTileData==null || tile.myTileData.tileCount<1) {
			if ((marked && tile.mark!=0) || (!marked && tile.mark==0))
				tVec.add(tile);
			return tVec;
		}
		
		// else go recursively into 'myTileData'
		for (int j=1;j<=tile.myTileData.tileCount;j++) {
			Tile mytile =tile.myTileData.myTiles[j];
			if ((mytile.mark!=0 && marked) || (mytile.mark==0 && !marked)) {
				Vector<Tile> tmpV=new Vector<Tile>();
				tmpV=accumMarked(mytile,depth-1,marked);
					for (int k=0;k<tmpV.size();k++)
						tVec.add(tmpV.get(k));
			}
		}
		return tVec;
	}
	
	/**
	 * Given a packing, check if it has 'TileData' with 'tileCount'
	 * equal to some depth of tilingdata in the existing hierarchy. If
	 * not, return -1;
	 * @param p
	 * @return depth or -1 on no match
	 */
	public int whatDepth(PackData p) {
		if (p==null || p.tileData==null || p.tileData.tileCount==0 ||
				canonicalPack==null || canonicalPack.tileData==null ||
				canonicalPack.tileData.gradedTileData==null)
			return -1;
		Vector<TileData> gTD=canonicalPack.tileData.gradedTileData;
		int depth=-1;
		for (int j=0;(j<gTD.size() && depth<0);j++)
			if (gTD.get(j).tileCount==p.tileData.tileCount)
				depth=j;
		if (depth<0 && p.tileData.tileCount==canonicalPack.tileData.tileCount)
			depth=canonicalPack.tileData.gradedTileData.size();
		return depth;
	}
	
	/**
	 * Return vector of 'VertAim' objects (w,ang) where w is augmented vert
	 * (or else regular vert) of tile 'tnum' and ang the sum of angles at w 
	 * in the faces of that tile. 
	 * 
	 * NOTE: useful for imposing these as boundary angle, but only in
	 * euclidean case.
	 * 
	 * @param p PackData; should be euclidean
	 * @param tile Tile; assumed associated with p
	 * @return double[] of angles
	 */
	public double []tileCornerAngles(PackData p,Tile tile) {
		if (p==null || p.hes!=0 || tile==null) 
			return null;
		double []ans=new double[tile.augVertCount];
		try {
			int bcount=0;
			int []bdryverts=null;
			if (tile.augVertCount>0) {
				bcount=tile.augVertCount;
				bdryverts=new int[bcount];
				for (int i=0;i<bcount;i++)
					bdryverts[i]=tile.augVert[i];
			}
			else {
				bcount=tile.augVertCount;
				bdryverts=new int[bcount];
				for (int i=0;i<bcount;i++)
					bdryverts[i]=tile.vert[i];
			}
		
			for (int i=0;i<bcount;i++) {
				double accum=0.0;
				int w=bdryverts[i];
				int uj=p.nghb(w,bdryverts[(i-1+bcount)%bcount]); // index of upstream nghb
				int dj=p.nghb(w,bdryverts[(i+1)%bcount]); // index of downstrem nghb
				int []fan=p.flowerFan(w,dj,uj);
				int N=fan.length;
				double r=p.getRadius(w);
				for (int j=0;j<(N-1);j++) {  // note: assuming euclidean tangency packing
					double e1=r+p.getRadius(fan[j]); // edge lengths
					double e2=r+p.getRadius(fan[j+1]);
					double eo=e1+e2-2*r; // opp edge length
					accum = accum+Math.acos((e1*e1+e2*e2-eo*eo)/(2.0*e1*e2));
				}
				ans[i]=accum;
			}
		} catch (Exception ex) {
			throw new CombException("packing and tile not compatible??");
		}
		
		return ans;
	}
	
	/**
	 * When getting copy of saved packing, must trace, make copies, and relink
	 * the various 'TileData'. This involves resetting 'MyTileData' and
	 * 'TDParent', setting 'TileData.packData', etc. This must be reset
	 * by calling routine.
	 * @param depthPacking Vector<Vector<PackData>
	 * @return original PackData, but with revamped 'TileData' stuff.
	 */
	public static PackData copyDepthPacking(Vector<Vector<PackData>> depthPDs,int tiletype,int depth) {
		if (depthPDs==null || tiletype<4 || depthPDs.size()<(tiletype+1))
			return null;
		Vector<PackData> vecPD=depthPDs.get(tiletype);
		if (vecPD==null || vecPD.size()<(depth+1) || vecPD.get(depth)==null)
			return null;
		PackData packData=vecPD.get(depth).copyPackTo(true);
		return packData;
	}
		
	public void initCmdStruct() {
		super.initCmdStruct();
		cmdStruct.add(new CmdStruct("set_mode","[mode]",null,"Mode 1 = simple (this can fail); 2 = with edge barycenters;"
				+ "3 = barycentrically subdivided (default)"));
		cmdStruct.add(new CmdStruct("set_type","{x} -t {t..}",null,"Set tile type to {x} for listed tiles"));
		cmdStruct.add(new CmdStruct("set_TD","[d]",null,"Attaching tiling data to active pack; if 'canonicalPack' "+
				"has a TileData subdivision tree, then this loads the tiling at depth 'd', "
				+"defaulting to maximum depth"));
		cmdStruct.add(new CmdStruct("disp","-[[g]TDQ m] {j..} -[E -m{x}] {t..}",null,
				"display specified tiles: T = tiles, D = dual tiles, Q = quad tiles, "+
				"m = mark distinquished corners, "+
				" E = augmented tile edges marked with 'x'; "+
				"usual display options for color, thickness, fill. List appropriate tiles, "+
				"vertices, or edge barycenters. "+
				"[g] preceding flag means display associated grey/white subtiles instead."));
		cmdStruct.add(new CmdStruct("set_tflowers",null,null,"Set the 'tileFlower' data, telling each tile who its neighbors are"));
		cmdStruct.add(new CmdStruct("mark",null,null,"Set 'mark' for all vertices: 1 = tile barycenter; "+
				"2 = dual tile barycenter; 3 = quad tile barycenter; else 0"));
		cmdStruct.add(new CmdStruct("read_canon","{filename}",null,"Read a tiling file to replace "+
				"'canonicalPack'"));
		cmdStruct.add(new CmdStruct("get_canon",null,null,"convert the parent packing to "+
				"a clone of 'canonicalPack'"));
		cmdStruct.add(new CmdStruct("put_canon",null,null,"Use tiledata in parent to create a "+
				"new 'canonicalPack'. The parent is unchanged."));
		cmdStruct.add(new CmdStruct("export","-[mbc] {p}",null,"export a tile packing of "+
				"level n (m=minimal, c=canonicalPack, b=barycentric) to packing p"));
		cmdStruct.add(new CmdStruct("godual","x",null,"replace parent packing by the packing "+
				"for the dual tiling, x to also replace 'canonicalPack'. NOTE: original packing is lost."));
		cmdStruct.add(new CmdStruct("split3",null,null,"replace 'packData' with minimal packing but with "+
				"each tile edge split into three, mark 1 2 3 4 (baryVert, corner, two splits)"));
		cmdStruct.add(new CmdStruct("subdivide","{type}",null,"subdivide: type [shbqptd] star, "+
				"hex, bary, quad, pent, twist, delta"));
		cmdStruct.add(new CmdStruct("Vlist","-[TDQ][v] {j..}",null,"fill 'Vlist' using specified tile "+
				"indices 'j': list baryVerts, or with optional 'v', list tile vertices. 'T', 'D', 'Q' "+
						"for tiles, dual tiles, or quad tiles"));
		cmdStruct.add(new CmdStruct("load_rules","[[-s] filename]",null,"Load a Bill Floyd style *.r subdivision rule file"));
		cmdStruct.add(new CmdStruct("pave","v",null,"This tries to create a tiling for "+
				"'packData' made of its disjoint interior flowers, starting with v."));
		cmdStruct.add(new CmdStruct("stvl","{t} -{n}",null,"set vlist as boundary of tile 'n' levels up from tile 't'"));
		cmdStruct.add(new CmdStruct("build_sub","-d {x}",null,"Apply subdivision process to the current tiling, "+
				"depth 'x'. Resulting 'canonicalPack' is copied to active packing."));
		cmdStruct.add(new CmdStruct("subtile","{t} -d {x} -m {j}",null,"Create a tiling with single tile of "+
				"type 't', then subdivide to depth 'x' with 'mode' j (1, 2, or 3); original packing is lost"));
		cmdStruct.add(new CmdStruct("?angles","{t}",null,"List vertices and interior angle sums for tile 't'"));
		cmdStruct.add(new CmdStruct("feedback","-d {d} {{f1 t1}..{fn tn}}",null,
				"Feedback bdry angle data from tiles fj of a core at depth d > 0 to corresponding "+
				" tiles tj at depth 0; core should be simply connected. "+
				"Set parent bdry aims to Pi, then use feedback from the tiles at depth d to bdry "+
				"vertices of parent. Then ready to repack. Suitable for eucl case only."));
		cmdStruct.add(new CmdStruct("store_eucl",null,null,"Store eucl centers for tile "+
				"vertices if the geometric data is provided (optional, "+
				"in *.r rules file)"));
		cmdStruct.add(new CmdStruct("write_eucl",null,null,"Send euclidean tiling "+
				" to postscript file if the geometric data is provided (optional, "+
				"in *.r rules file)"));
		cmdStruct.add(new CmdStruct("draw_eucl",null,null,"Draw euclidean tiling "+
				"if the geometric data is provided (optional, "+
				"in *.r rules file)"));
		cmdStruct.add(new CmdStruct("set_tlist","[-P{d} {t..}]",null,"fill 'tlist' or 'Tlist' with "+
				"tiles whose parents at depth 'd' are in the list {t..} (default, one level up)"));
	}
	
}

/**
 * local class to hold {vert,aim} pairs from 'feedback' command
 * @author kens
 *
 */
class VertAim {
	public int vert;
	public double aim;
	
	public VertAim(int v,double a) {
		vert=v;
		aim=a;
	}
}
