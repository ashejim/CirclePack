package ftnTheory;

import java.io.BufferedWriter;
import java.io.File;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Vector;

import allMains.CPBase;
import allMains.CirclePack;
import combinatorics.komplex.DcelFace;
import combinatorics.komplex.HalfEdge;
import combinatorics.komplex.Vertex;
import complex.Complex;
import input.CPFileManager;
import komplex.EdgeSimple;
import listManip.EdgeLink;
import listManip.HalfLink;
import math.Point3D;
import packing.PackCreation;
import packing.PackData;
import packing.PackExtender;
import util.CmdStruct;

/**
 * This extender creates data for hexagonal patterns of unit
 * diameter spheres attached to cylinders. The parameters are
 * combinatorial, the fundamental vector given by p and q, and
 * the number of generations. Code was started in Matlab and
 * the data will be written to a file so it can be read and then
 * visualized in matlab. See '/newpapers/CylinderSpheres'.
 * 
 * The cylinder containing the sphere centers is Cyl(R). 
 * These spheres are tangent to Cyl(R-0.5) and lie 
 * inside Cyl(R+0.5). The dual of the hex triangulation 
 * gives the combinatorics of a buckytube, a pattern 
 * of hexagons. These vertices all lie on a common 
 * cylinder Cyl(carbonR), which can be computed.
 * 
 * The "base" sphere S0 is centered at (R,0,0). The 
 * spheres {S0,S1,S2} form a tangent triple, with 
 * the heights z1 and z2 of S1, S2 (resp.) being 
 * negative and positive. Sphere centers on Cyl(R) 
 * are first represented as points (t,z) in 2D, acting 
 * as the universal cover of Cyl(R). The hex lattice 
 * of points is generated by vectors V, W, where V 
 * is associated with the tangency S0, S1 and W with 
 * the tangency S0, S2. The fundamental vector for the
 * covering is F=p*V+q*W, so F=(2*pi*R,0).
 * 
 * We have closed expressions from some of our
 * quantities, but others must be approximated.
 * 
 * Combinatorics is respresented as sequence of n 
 * necklasses running from top to bottom, each a
 * close P Q chain of 'HalfEdge's.
 */
public class CylinderSpheres extends PackExtender {
	
	// combinatorial parameters for coherent cylindrical
	// sphere packing. Require 0<=Q<=P and P>=3.
	int P;
	int Q;
	int levelCount; // >= 3 in practice
	int baseLevel; // level of necklass starting at (R,0,0)
	int nodeCount; // final count of spheres after creation.
	int hexCount; // number of hex cells.
	
	// Key computational values are R and z1, 
	//   computed from P,Q
	double cylR; // mid cylinder radius, contains centers
	double cylz1; // z-height of S1
	
	// Remaining values computed from R and z1
	double cylz2; // z-height of S2
	double cylt1; // radian measure of S1 center
	double cylt2; // radian measure of S2 center
	double carbonR; // radius of cylinder for buckytube carbons

	// data for sending to matlab
	Complex[] cents2D; 
	Point3D[] barycenters; // face barycenters, carbon locations
	EdgeLink edgeLink; // indices: edges between tangent spheres
	EdgeLink hexLink; // carbon bond edges, using faceIndx
	ArrayList<HalfLink> necklasses;
	
	// keep track of status:
	//   0=nothing done; 
	//   1=P,Q,N and combinatorics in place;
	//   2=R, z1, t1, t2 computed
	//   3=data ready for matlab-type output
	int status; 

	public CylinderSpheres(PackData p) {
		super(p);
		extensionType="CylinderSpheres";
		extensionAbbrev="CS";
		toolTip="'CylinderSpheres' creates/manipulates buckytube "
				+ "type combinatorics and creates data for use in "
				+ "Matlab to display.";
		registerXType();
		if (running) {
			status=0;
			P=6;
			Q=6;
			levelCount=3;
			extenderPD.packExtensions.add(this);
		}
	}
	
	public int cmdParser(String cmd,Vector<Vector<String>> flagSegs) {
		Vector<String> items=null;
		int count=0;
		
		// ============== param =========================
		if (cmd.startsWith("param")) {
			status=0; // we're restarting
			try {
				items=flagSegs.get(0);
				int p=Integer.parseInt(items.get(0));
				int q=Integer.parseInt(items.get(1));
				if (p<q) {
					int hold=p;
					p=q;
					q=hold;
				}
				if (q<0 || p<3) {
					CirclePack.cpb.errMsg("must have q>0 and p<3");
					return 0;
				}
				P=p;
				Q=q;
				if (items.size()>2) {
					int n=Integer.parseInt(items.get(2));
					if (n<3)
						n=3;
					levelCount=n;
				}
				else 
					levelCount=3;
			} catch(Exception ex) {
				Oops("usage: |cs| param {p,q}");
				return 0;
			}
				
			// create the cylindrical hex combinatorics
			PackData newPack=PackCreation.hexCylinder(P, Q, levelCount);
			newPack.status=true;
			int pnum=extenderPD.packNum;
			extenderPD=CirclePack.cpb.swapPackData(newPack,pnum,true);
			nodeCount=extenderPD.nodeCount;
			count++;
			status =1;
			
		}
		
		// =================== compute ==============
		else if (cmd.startsWith("comp")) {
			if (status==0) {
				Oops("Must first call '|cs| parameters p q [n]'");
				return count;
			}
			double[] results=computeRz(P,Q);
			cylR=results[0];
			cylz1=results[1];
			cylt1=what_is_t(cylR,cylz1);
			Complex s2=computeS2(cylR,cylz1);
			cylt2=s2.x;
			cylz2=s2.y;

			status=1;
			if ((results[2]+results[3])>.001) {
				CirclePack.cpb.msg("in 'comp', errors too large: t_error = "+results[2]+", z_error = "+results[3]);
			}
			count++;
			CirclePack.cpb.msg("Have computed R = "+cylR+" and z1 = "+cylz1);
			
		}
		
		// ====================== data =====================
		// lots to do here. I'll organize data based on the
		//   succession of necklasses, from top to bottom,
		//   with data in successive rows of 'cents2D'.
		//
		//   'cents2D' will be a n*(p+q) array with
		//   complex entries t+iz. This is based on 'levelCount'
		//   necklasses, P+Q spheres in each necklass.
		//
		//   'hexcells' will be associated with interior
		//   vertices, proceeding necklass by necklass from
		//   top-1 to bottom+1. Note, there will be redundancies.
		//   		
		else if (cmd.startsWith("data")) {

			// shifts: V in P direction, W in Q direction
			//   U down and right to shift necklasses.
			Complex V=new Complex(cylt1,cylz1);
			Complex W=new Complex(cylt2,cylz2);
			Complex U=V.minus(W);

			// 'alpha' edge should go from 1 to 2. 
			//   This should be parallel to boundary, but 
			//   pointed left; use it to find 'topbase' as 
			//   upper left corner, pointed clw on bdry. 
			// Then build 'levelCount' necklasses. 
			HalfEdge hetrace=extenderPD.packDCEL.alpha;
			hetrace=hetrace.twin.prev.twin.prev.twin.prev;
			hetrace=hetrace.prev.twin.prev;
			HalfEdge topbase=hetrace.prev.twin;
			necklasses=new ArrayList<HalfLink>(3);
			
			HalfEdge starter=topbase;
			for (int k=1;k<levelCount;k++) {
				necklasses.add(necklass(starter,false));
				starter=starter.twin.prev.twin.next;
			}
			// add last (requires clw=true)
			necklasses.add(necklass(starter,true));
			
			// build desired redChain; left side, top
			//   to bottom, last necklass, right side,
			//   bottom to top, then first twins in
			//   reverse order.
			HalfEdge he=topbase.twin.next;
			for (int j=1;j<(levelCount-1);j++) {
				he=he.next.twin.next.twin.next;
			}

			// left turn depends on Q>0 or Q=0
			if (Q>0)
				he=he.next.twin.next;
			else
				he=he.next;
			for (int j=1;j<(levelCount-1);j++) {
				he=he.next.twin.next.twin.next;
			}
			HalfLink top=necklasses.get(0);
			top=HalfLink.reverseElements(top);
			top=HalfLink.reverseLink(top);

			// Now preferred redchain 
/*			extenderPD.vlist=new NodeLink(top);
			if (cpCommand("newRed vlist")==0)
				Oops("Failed to form new redchain");
*/
			
			// find centers along first row, then shift
			//   to complete successive rows. Our leftshift
			//   will mean the sphere at (R,0,0) (the
			//   base sphere) will be about half way down
			//   the left side.
			cents2D=new Complex[levelCount*(P+Q)+1];
			Point3D[] tmp3D=new Point3D[levelCount*(P+Q)+1];
			baseLevel=(int)(levelCount/2);
			if (2*(levelCount/2)!=2)
				baseLevel++;
			
			// position top necklass, set 'origin.center's
			//   and entries in 'cents2D'. Also set
			//   vertices 'vutil' to correspond with index
			//   in cents2D.
			int vtick=0;
			Complex nextcent=U.times(-1.0*(double)baseLevel);
			Iterator<HalfLink> nls=necklasses.iterator();
			HalfLink hlink=nls.next();
			Iterator<HalfEdge> hls=hlink.iterator();
			he=hls.next();
			Vertex vert=he.origin;
			vert.center=nextcent;
			vert.vutil=++vtick;
			cents2D[vtick]=nextcent;
			tmp3D[vert.vertIndx]=set3D(cylR,cents2D[vtick]);
			int endP=P;
			if (Q==0) // leave of P_th one
				endP=P-1;
			for (int j=1;j<=endP;j++) {
				he=hls.next();
				nextcent=nextcent.add(V);
				cents2D[++vtick]=nextcent;
				tmp3D[he.origin.vertIndx]=set3D(cylR,cents2D[vtick]);
				he.origin.center=nextcent;
				he.origin.vutil=vtick;
			}
			if (Q>0) {  // 3*cylz1+cylz2
				for (int j=2;j<=Q;j++) {
					he=hls.next();
					nextcent=nextcent.add(W);
					cents2D[++vtick]=nextcent;
					tmp3D[he.origin.vertIndx]=set3D(cylR,cents2D[vtick]);
					he.origin.center=nextcent;
					he.origin.vutil=vtick;
				}
			}
			
			// now replicate on subsequent necklasses
			for (int row=2;row<=levelCount;row++) {
				Complex sU=U.times((double)(row-1));
				hlink=nls.next();
				hls=hlink.iterator();
				vert=hls.next().origin;
				vert.vutil=++vtick;
				cents2D[vtick]=cents2D[1].add(sU);
				tmp3D[vert.vertIndx]=set3D(cylR,cents2D[vtick]);
				for (int j=2;j<=(P+Q);j++) {
					vert=hls.next().origin;
					vert.vutil=++vtick;
					vert.center=cents2D[vtick]=cents2D[j].add(sU);
					tmp3D[vert.vertIndx]=set3D(cylR,cents2D[vtick]);
				}
			}	
			
			// find all face 3D barycenters
			barycenters=new Point3D[extenderPD.faceCount+1];
			double nrm=cylR;
			for (int f=1;f<=extenderPD.faceCount;f++) {
				DcelFace face=extenderPD.packDCEL.faces[f];
				Point3D[] c=new Point3D[3];
				int[] verts=face.getVerts();
				for (int m=0;m<3;m++)
					c[m]=tmp3D[verts[m]];
				barycenters[f]=new Point3D(
						(c[0].x+c[1].x+c[2].x)/3.0,
						(c[0].y+c[1].y+c[2].y)/3.0,
						(c[0].z+c[1].z+c[2].z)/3.0);
				nrm=barycenters[f].norm();
			}
			carbonR=nrm; //barycenters[1].norm(); // all 3D norms should be equal

			// create 'edgeLink'. Note that vertex 'vutil' 
			//   agrees with its index in cents2D. 'edgeLink'
			//   is pairs of 'vutil' indices.
			
			// Start with top and bottom necklass rows; 
			// to avoid repeats, make sure that edge 
			// (v,w) has v<w. We will get rest of edges
			// as we process successive interior necklasses.
			edgeLink=new EdgeLink();
			
			hlink=necklasses.get(0);
			hls=hlink.iterator();
			while (hls.hasNext()) {
				he=hls.next();
				int vv=he.origin.vutil;
				int ww=he.twin.origin.vutil;
				if (ww<vv) {
					int hold=vv;
					vv=ww;
					ww=hold;
				}
				EdgeSimple es=new EdgeSimple(vv,ww);
				edgeLink.add(es);
			}
			hlink=necklasses.get(necklasses.size()-1);
			hls=hlink.iterator();
			while (hls.hasNext()) {
				he=hls.next();
				int vv=he.origin.vutil;
				int ww=he.twin.origin.vutil;
				if (ww<vv) {
					int hold=vv;
					vv=ww;
					ww=hold;
				}
				EdgeSimple es=new EdgeSimple(vv,ww);
				edgeLink.add(es);
			}
			
			// proceed through interior necklasses: store 
			//   individual hexcells and make 'edgeLink' entries
			//   (possibly redundant). 
			hexLink=new EdgeLink((PackData)null);
			nls=necklasses.iterator();
			nls.next(); // toss first, and ignore last (bdry)
			for (int r=2;r<levelCount;r++) {
				hlink=nls.next();
				hls=hlink.iterator();
				while (hls.hasNext()) {
					he=hls.next();
					for (int k=1;k<=6;k++) {
						// add bond edge to hexLink
						int vv=he.face.faceIndx;
						int ww=he.twin.face.faceIndx;
						if (ww<vv) {
							int hold=vv;
							vv=ww;
							ww=hold;
						}
						EdgeSimple es=new EdgeSimple(vv,ww);
						hexLink.add(es);
						
						// add tangency edge to edgeLink
						vv=he.origin.vutil;
						ww=he.twin.origin.vutil;
						if (ww<vv) {
							int hold=vv;
							vv=ww;
							ww=hold;
						}
						es=new EdgeSimple(vv,ww);
						edgeLink.add(es);
						
						he=he.prev.twin; // next spoke cclw
					}
				}
			}
			
			// remove redundancies
			edgeLink=edgeLink.makeCopy(true);
			hexLink=hexLink.makeCopy(true);
			status=3; // ready to share with Matlab
			count++;
		}
		
		else if (cmd.startsWith("output")) {
			File tmpdir=new File(CPFileManager.HomeDirectory+
				"/Documents/NewPapers/CylinderSpheres/CPdata");
			StringBuilder strbuf=new StringBuilder();
			boolean append_flag=false;
			boolean script_flag=false;
			File file=new File("hexCyl_"+P+"_"+Q+"_"+levelCount+".m");
			// there may be a filename given
			int code=CPFileManager.trailingFile(flagSegs, strbuf);
			if (code!=0) {
				file=new File(strbuf.toString());
				script_flag=((code & 04)==04);
				append_flag=((code & 02)==02);
			}
			BufferedWriter fp=CPFileManager.openWriteFP(tmpdir,append_flag,
				file.getName(),script_flag);
			try {
				fp.write("% Output from CirclePack extender 'CylinderSpheres'\n\n");
				fp.write("r="+cylR+"; z="+cylz1+";\n");
				fp.write("HC=HexCylinder(r,z);\n\n");
				fp.write("% Specified parameters:\n");
				fp.write("HC.p="+P+";\n"+"HC.q="+Q+";\nHC.nodeCount="+nodeCount+
						";\nHC.levelCount="+levelCount+";\nHC.baseLevel="+baseLevel+";\n\n");
				fp.write("% Computed values:\n");
				fp.write("HC.R="+cylR+";\nHC.t1="+cylt1+";\nHC.z1="+cylz1+
						";\nHC.t2="+cylt2+";\nHC.z2="+cylz2+";\n\n");
				if (cents2D!=null) {
					fp.write("HC.cents2D = [\n");
					for (int j=1;j<=nodeCount;j++) {
						Complex z=cents2D[j];
						fp.write(z.x+", "+z.y+";\n");
					}
					fp.write("];\n\n");
				}
				
//				if (cents3D!=null) {
//					fp.write("HC.cents3D = [\n");
//					for (int j=1;j<=nodeCount;j++) {
//						Point3D pt=cents3D[j];
//						fp.write(pt.x+", "+pt.y+", "+pt.z+";\n");
//					}
//					fp.write("];\n\n");
//				}
				
				if (edgeLink!=null && edgeLink.size()>0) {
					fp.write("HC.edgeLink = [\n");
					Iterator<EdgeSimple> est=edgeLink.iterator();
					while (est.hasNext()) {
						EdgeSimple es=est.next();
						fp.write(es.v+", "+es.w+";\n");
					}
					fp.write("];\n\n");
				}
				
				if (barycenters!=null && barycenters.length!=0) {
					fp.write("HC.barycenters = [\n");
					for (int j=1;j<=extenderPD.faceCount;j++) {
						Point3D pt3=barycenters[j];
						fp.write(pt3.x+", "+pt3.y+", "+pt3.z+";\n");
					}
					fp.write("];\n\n");
				}
				
				if (hexLink!=null && hexLink.size()>0) {
					fp.write("HC.hexLink = [\n");
					Iterator<EdgeSimple> hst=hexLink.iterator();
					while (hst.hasNext()) {
						EdgeSimple es=hst.next();
						fp.write(es.v+", "+es.w+";\n");
					}
					fp.write("];\n\n");
				}
				
				// have matlab compute cents3D
				fp.write("HC.HCcomp3D();\n");
				
				CirclePack.cpb.msg("Data for Matlab stored in '"+
				file.getName()+"'");
				status=4;
				
				fp.flush();
				fp.close();
			} catch(Exception ex) {
				System.err.print(ex.toString());
			    try {
			    	fp.flush();
					fp.close();
			    } catch (Exception exe) {}
			}
			count++;
		}
		
		return count;
	} // end of cmd parsing

	/**
	 * Build P Q closed necklass starting with
	 * horizontal edge 'startedge'. So P steps
	 * horizontal, then a slight left turn and
	 * Q steps. This is a closed chain of edges.
	 * Note that for the bottom chain, have to
	 * advance clockwise about vertices. 
	 * @param startedge HalfEdge
	 * @param clw boolean; true, advance clockwise
	 * @return HalfLink
	 */
	public HalfLink necklass(HalfEdge startedge,boolean clw) {
		HalfLink hlink=new HalfLink(extenderPD);
		HalfEdge he=startedge;
		hlink.add(he);
		for (int j=1;j<P;j++) {
			if (clw)
				he=he.next.twin.next.twin.next;
			else
				he=he.twin.prev.twin.prev.twin.prev.twin;
			hlink.add(he);
		}
		if (Q>0) {
			if (clw) 
				he=he.next.twin.next;
			else
				he=he.twin.prev.twin.prev.twin.prev.twin.prev.twin;
			hlink.add(he);
			if (Q>1) {
				for (int j=1;j<Q;j++) {
					if (clw)
						he=he.next.twin.next.twin.next;
					else
						he=he.twin.prev.twin.prev.twin.prev.twin;
					hlink.add(he);
				}
			}
		}
		return hlink;
	}

	/**
	 * Start from scratch, only knowing p and q, and 
	 * compute R, z_1, and errors: abs(p*t1+q*t2-2*pi*R) 
	 * and abs(p*z1+q*z2). 
	 * @param p int
	 * @param q int
	 * @return double[], [R,z1,t_error,z_error]
	 */
	public double[] computeRz(int p,int q) {
		double R;
		double z1;
		
		// set R between min/max possible, but not less than 0.5
		R=(p+q)/(3*Math.PI); 
		if (R<0.5)
			R=0.5;
		if (p<q) {
			int hold=p;
			p=q;
			q=hold;
		}

		// special situations
		if (p==q) {
		    double[] ans=new double[4];
			ans[0]=Math.sqrt(3.0/(8.0*(1.0-Math.cos(2.0*Math.PI/(2.0*p)))));
		    ans[1]=-0.5;
		    ans[2]=0;
			ans[3]=0;
			return ans;
		}
		if (q==0) {
		    double[] ans=new double[4];
			ans[0]=Math.sqrt(1.0/(2.0*(1.0-Math.cos(2.0*Math.PI/p))));
			ans[1]=0;
			ans[2]=0;
			ans[3]=0;
			return ans;
		}
		
		z1=what_is_z1(R,p,q,-1.0); // get started
		double t1=what_is_t(R,z1);
		Complex s1=computeS2(R,z1);
		double t_error=Math.abs(p*t1+q*s1.x-R*CPBase.pi2);
		double z_error=Math.abs(p*z1+q*s1.y);
		int safety=1000;
		while ((t_error+z_error)>.000001 && safety>0) {
		    safety=safety-1;
		    R=newtees(R,z1,p,q);
		    z1=what_is_z1(R,p,q,z1);
		    t1=what_is_t(R,z1);
		    Complex s2=computeS2(R,z1);
		    t_error=Math.abs(p*t1+q*s2.x-R*CPBase.pi2);
		    z_error=Math.abs(p*z1+q*s2.y);
		}
		double[] ans=new double[4];
		if (safety==0)
		    CirclePack.cpb.errMsg("safetied out in 'computeRz'");
		ans[0]=R;
		ans[1]=z1;
		ans[2]=t_error;
		ans[3]=z_error;
		return ans;
	}

	/**
	 * Give a cylinder of radius R, S0 the base sphere
	 * at (R,0,0), S1 tangent to S0 with height z1, find
	 * height z2>=0 and arclength value t2 of S2 which is
	 * tangent to both S0 and S1.
	 * @param R double, cylinder radius
	 * @param z1 double, height of S1
	 * @return Complex t+iz
	 */
	public Complex computeS2(double R,double z1) {
		z1=-1*Math.abs(z1); // z1 should lie in (-ZR,0].
		double ZR=what_is_Z_R(R);	
		if (z1<-1.0*ZR)
			z1=-1.0*ZR;	
		double min_z=0;
		double max_z=ZR;
		double z2=min_z;
		double best=S2_distance(R,z1,z2);
		int safety=1000;
		// TODO: improve using Newton method
		while (Math.abs(best-1.0)>0.0000000000001 && safety>0) {
			safety=safety--;
	    	z2=(min_z+max_z)/2.0;
	    	best=S2_distance(R,z1,z2);
	    	if (best<1)
	    		min_z=z2;
	    	else if (best>1)
	    		max_z=z2;
		}
		if (safety==0) {
			if (Math.abs(best-1.0)>.001) {
	        	CirclePack.cpb.errMsg("safety error in computeS2");
	        	return null; 
			}
		}
		double t2=R*Math.acos(1+(z2*z2-1)/(2*R*R));
		return new Complex(t2,z2);
	}

	/**
	 * Adjust R so p*t1+q*t2=2*pi*R=0.
	 * @param RR double
	 * @param zz1 double
	 * @param p int
	 * @param q int
	 * @return double
	 */
	public double newtees(double RR,double zz1,int p,int q) {
		double R=RR;
		double z1=zz1;
		double t1=what_is_t(R,z1);
		Complex s2=computeS2(R,z1);
		double value=p*t1+q*s2.x-2.0*Math.PI*R; // want this to be zero.
		int safety=1000;
		while (Math.abs(value)>.000000001 && safety>0) {
		    safety--;
		    double dt1=der_tz(R,z1);
		    double dt2=der_tz(R,s2.y);
		    double dvdR=p*dt1+q*dt2-2*Math.PI; // derivative or value wrt R
		    R=R-value/dvdR;
		    t1=what_is_t(R,z1);
		    s2=computeS2(R,z1);
		    value=p*t1+q*s2.x-2.0*Math.PI*R;
		}
		if (safety==0)
		    CirclePack.cpb.errMsg("safetied out in 'newtees'");
		return R;
	}

	/**
	 * Assuming vertex centers have been set as t+iz,
	 * need to compute the 3D barycenter of the triangle
	 * for the face on the left of 'edge'
	 * @param R double, cylinder radius
	 * @param edge HalfEdge
	 * @return Point3D
	 */
	public Point3D faceBarycenter(double R,HalfEdge edge) {
		Complex a=edge.origin.center;
		Complex b=edge.next.origin.center;
		Complex c=edge.next.next.origin.center;
		Point3D a3D=set3D(R,a);
		Point3D b3D=set3D(R,b);
		Point3D c3D=set3D(R,c);
		double cx=(a3D.x+b3D.x+c3D.x)/3.0;
		double cy=(a3D.y+b3D.y+c3D.y)/3.0;
		double cz=(a3D.z+b3D.z+b3D.z)/3.0;
		return new Point3D(cx,cy,cz);
	}

	/**
	 *  d = S2_distance(R,z1,x) distance, S2 to S1 as function of x
	 *  Find the distance of the center of S2 as a function
	 *  of its height x >= 0. We use intermediate quantities 
	 *  c=cos(t/R) and s=sin(t/R).
	 *  For spheres tangent to S_0, c and z are related by
	 *      c=1+(z^2-1)/(2R^2)
	 */
	public double S2_distance(double R,double z1,double x) {
		// (a) Find c1:
		double c1=1.0+(z1*z1-1.0)/(2.0*R*R);
		double s1=Math.sqrt(1.0-c1*c1);
		// (b) Find c2 as a function of x
		double c2=1.0+(x*x-1)/(2*R*R);
		double s2=Math.sqrt(1.0-c2*c2);
		double d=(x-z1)*(x-z1)-(2*R*R)*(c1*c2+s1*s2-1.0);
		return Math.sqrt(d);
	}

	/**
	 * partial derivative of t wrt z. Note t=t1 then 
	 * z=z1, while t=t2 then z=z2.
	 * @param R double
	 * @param z double
	 * @return double
	 */
	public double der_tz(double R,double z) {
		double y=(1.0-z*z);
		return -2.0*R*z/(Math.sqrt(y)*Math.sqrt(4.0*R*R-y));
	}
	
	/**
	 * Given R (and z1), adjust z1 until pz1+qz2=0;
	 * @param R double
	 * @param p int
	 * @param q int
	 * @param z1 double
	 * @return double
	 */
	public double what_is_z1(double R,int p,int q,double z1) {
		if (q==0)
			return 0;

		double max_z1=0;
		double ZR=what_is_Z_R(R);
		double min_z1=-ZR;
		if (z1<-.9)
			z1=min_z1;
		double z_out=z1;
		Complex s2=computeS2(R,z1);
		double p1q2=p*z_out+q*s2.y;
		int safety=1000;
		while (Math.abs(p1q2)>.00000001) {
			safety--;
			if (p1q2>0) {
				max_z1=z_out;
				z_out=(z_out+min_z1)/2;
			}
			else if (p1q2<0) {
			    min_z1=z_out;
			    z_out=(z_out+max_z1)/2;
			}
			s2=computeS2(R,z_out);
			p1q2=p*z_out+q*s2.y;
		}
		if (safety==0) {
			CirclePack.cpb.errMsg("safety'ed out in computeRz");
		}
		return z_out;
	}
	
	public double what_is_t(double R,double z1) {
		return R*Math.acos(1.0+(z1*z1-1.0)/(2.0*R*R));
	}
	
	public double what_is_Z_R(double R) {
		return Math.sqrt(1.0+2.0*R*R*(Math.sqrt(1.0-1.0/(4.0*R*R))-1.0));
	}

	/**
	 * Convert planar point t+iz into Point3D on cylinder
	 * of radius R
	 * @param R double
	 * @param pt Complex
	 * @return Point3D
	 */
	public Point3D set3D(double R,Complex pt) {
		double t=pt.x;
		return new Point3D(R*Math.cos(t/R),R*Math.sin(t/R),pt.y);
	}

	public void initCmdStruct() {
		super.initCmdStruct();
		cmdStruct.add(new CmdStruct("parameters","p q [n]",null,
				"Given p, q, n (default 3), build packing"));
		cmdStruct.add(new CmdStruct("compute",null,null,
				"Compute R,z1, etc."));
		cmdStruct.add(new CmdStruct("data",null,null,
				"generate the data for output"));
		cmdStruct.add(new CmdStruct("output",null,null,
				"write data to matlab-type file"));
	}
		
}

